#include <atomic>
#include <cstring>
#ifdef SEASTAR_USE_STD_OPTIONAL_VARIANT_STRINGVIEW
#include <optional>
#include <variant>
#endif
#if __cplusplus >= 201703L && __has_include(<filesystem>)
#include <filesystem>
#include <memory_resource>
namespace seastar {
 namespace compat { using memory_resource = std::pmr::memory_resource; template<typename T> using polymorphic_allocator = std::pmr::polymorphic_allocator<T>; static inline memory_resource* pmr_get_default_resource() {     return std::pmr::get_default_resource(); } }
 }
#endif
namespace seastar {
 namespace compat {  
#ifdef SEASTAR_USE_STD_OPTIONAL_VARIANT_STRINGVIEW
template <typename T> using optional = std::optional<T>; using nullopt_t = std::nullopt_t; inline constexpr auto nullopt = std::nullopt; template <typename T> inline constexpr optional<std::decay_t<T>> make_optional(T&& value) {     return std::make_optional(std::forward<T>(value)); } template <typename CharT, typename Traits = std::char_traits<CharT>> using basic_string_view = std::basic_string_view<CharT, Traits>; template <typename CharT, typename Traits = std::char_traits<CharT>> std::string string_view_to_string(const basic_string_view<CharT, Traits>& v) {     return std::string(v); } template <typename... Types> using variant = std::variant<Types...>; template <std::size_t I, typename... Types> constexpr std::variant_alternative_t<I, variant<Types...>>& get(variant<Types...>& v) {     return std::get<I>(v); } template <std::size_t I, typename... Types> constexpr const std::variant_alternative_t<I, variant<Types...>>& get(const variant<Types...>& v) {     return std::get<I>(v); } template <std::size_t I, typename... Types> constexpr std::variant_alternative_t<I, variant<Types...>>&& get(variant<Types...>&& v) {     return std::get<I>(v); } template <std::size_t I, typename... Types> constexpr const std::variant_alternative_t<I, variant<Types...>>&& get(const variant<Types...>&& v) {     return std::get<I>(v); } template <typename U, typename... Types> constexpr U& get(variant<Types...>& v) {     return std::get<U>(v); } template <typename U, typename... Types> constexpr const U& get(const variant<Types...>& v) {     return std::get<U>(v); } template <typename U, typename... Types> constexpr U&& get(variant<Types...>&& v) {     return std::get<U>(v); } template <typename U, typename... Types> constexpr const U&& get(const variant<Types...>&& v) {     return std::get<U>(v); } template <typename U, typename... Types> constexpr U* get_if(variant<Types...>* v) {     return std::get_if<U>(v); } template <typename U, typename... Types> constexpr const U* get_if(const variant<Types...>* v) {     return std::get_if<U>(v); }  
#endif
namespace filesystem = std::filesystem; using string_view = basic_string_view<char>; }
  }
#if __cplusplus >= 201703L && defined(__cpp_guaranteed_copy_elision)
#endif
namespace seastar {
 class deleter final { public:     struct impl;     struct raw_object_tag {}; private:     impl* _impl = nullptr; public:     deleter() = default;     deleter(const deleter&) = delete;     deleter(deleter&& x)  ;     explicit deleter(impl* i)  ;     deleter(raw_object_tag tag, void* object)  ;     ~deleter();     deleter& operator=(deleter&& x) noexcept;     deleter& operator=(deleter&) = delete;     deleter share();     explicit operator bool() const ;     void reset(impl* i) ;     void append(deleter d); private:     static bool is_raw_object(impl* i) {         auto x = reinterpret_cast<uintptr_t>(i);         return x & 1;     }     bool is_raw_object() const {         return is_raw_object(_impl);     }     static void* to_raw_object(impl* i) {         auto x = reinterpret_cast<uintptr_t>(i);         return reinterpret_cast<void*>(x & ~uintptr_t(1));     }     void* to_raw_object() const {         return to_raw_object(_impl);     }     impl* from_raw_object(void* object) {         auto x = reinterpret_cast<uintptr_t>(object);         return reinterpret_cast<impl*>(x | 1);     } };
 struct deleter::impl {     unsigned refs = 1;     deleter next;     impl(deleter next) : next(std::move(next)) {}     virtual ~impl() {} };
 inline deleter::~deleter() {     if (is_raw_object()) {         std::free(to_raw_object());         return;     }     if (_impl && --_impl->refs == 0) {         delete _impl;     } }
 inline deleter& deleter::operator=(deleter&& x) noexcept {     if (this != &x) {         this->~deleter();         new (this) deleter(std::move(x));     }     return *this; }
 template <typename Deleter> struct lambda_deleter_impl final : deleter::impl {     Deleter del;     lambda_deleter_impl(deleter next, Deleter&& del)         : impl(std::move(next)), del(std::move(del)) {}     virtual ~lambda_deleter_impl() override { del(); } };
 template <typename Object> struct object_deleter_impl final : deleter::impl {     Object obj;     object_deleter_impl(deleter next, Object&& obj)         : impl(std::move(next)), obj(std::move(obj)) {} };
 template <typename Object> inline object_deleter_impl<Object>* make_object_deleter_impl(deleter next, Object obj) {     return new object_deleter_impl<Object>(std::move(next), std::move(obj)); }
 template <typename Object> deleter make_deleter(deleter next, Object o) {     return deleter(new lambda_deleter_impl<Object>(std::move(next), std::move(o))); }
 template <typename Object> deleter make_deleter(Object o) {     return make_deleter(deleter(), std::move(o)); }
 struct free_deleter_impl final : deleter::impl {     void* obj;     free_deleter_impl(void* obj) : impl(deleter()), obj(obj) {}     virtual ~free_deleter_impl() override { std::free(obj); } };
 inline deleter deleter::share() {     if (!_impl) {         return deleter();     }     if (is_raw_object()) {         _impl = new free_deleter_impl(to_raw_object());     }     ++_impl->refs;     return deleter(_impl); }
 inline void deleter::append(deleter d) {     if (!d._impl) {         return;     }     impl* next_impl = _impl;     deleter* next_d = this;     while (next_impl) {         if (next_impl == d._impl) {             return;          }         if (is_raw_object(next_impl)) {             next_d->_impl = next_impl = new free_deleter_impl(to_raw_object(next_impl));         }         if (next_impl->refs != 1) {             next_d->_impl = next_impl = make_object_deleter_impl(deleter(next_impl), std::move(d));             return;         }         next_d = &next_impl->next;         next_impl = next_d->_impl;     }     next_d->_impl = d._impl;     d._impl = nullptr; }
 inline deleter make_free_deleter(void* obj) {     if (!obj) {         return deleter();     }     return deleter(deleter::raw_object_tag(), obj); }
 inline deleter make_free_deleter(deleter next, void* obj) {     return make_deleter(std::move(next), [obj] () mutable { std::free(obj); }); }
 template <typename T> inline deleter make_object_deleter(T&& obj) {     return deleter{make_object_deleter_impl(deleter(), std::move(obj))}; }
 template <typename T> inline deleter make_object_deleter(deleter d, T&& obj) {     return deleter{make_object_deleter_impl(std::move(d), std::move(obj))}; }
 }
#include <algorithm>
namespace seastar {
 template <typename CharType> class temporary_buffer {     static_assert(sizeof(CharType) == 1, "must buffer stream of bytes");     CharType* _buffer;     size_t _size;     deleter _deleter; public:     explicit temporary_buffer(size_t size)         : _buffer(static_cast<CharType*>(malloc(size * sizeof(CharType)))), _size(size)         , _deleter(make_free_deleter(_buffer)) {         if (size && !_buffer) {             throw std::bad_alloc();         }     }     temporary_buffer()         : _buffer(nullptr)         , _size(0) {}     temporary_buffer(const temporary_buffer&) = delete;     temporary_buffer(temporary_buffer&& x) noexcept : _buffer(x._buffer), _size(x._size), _deleter(std::move(x._deleter)) {         x._buffer = nullptr;         x._size = 0;     }     temporary_buffer(CharType* buf, size_t size, deleter d)         : _buffer(buf), _size(size), _deleter(std::move(d)) {}     temporary_buffer(const CharType* src, size_t size) : temporary_buffer(size) {         std::copy_n(src, size, _buffer);     }     void operator=(const temporary_buffer&) = delete;     temporary_buffer& operator=(temporary_buffer&& x) noexcept {         if (this != &x) {             _buffer = x._buffer;             _size = x._size;             _deleter = std::move(x._deleter);             x._buffer = nullptr;             x._size = 0;         }         return *this;     }     const CharType* get() const { return _buffer; }     CharType* get_write() ;     size_t size() const ;     const CharType* begin() const ;     const CharType* end() const ;     temporary_buffer prefix(size_t size) && ;     CharType operator[](size_t pos) const ;     bool empty() const ;     explicit operator bool() const ;     temporary_buffer share() ;     temporary_buffer share(size_t pos, size_t len) ;     temporary_buffer clone() const ;     void trim_front(size_t pos) ;     void trim(size_t pos) ;     deleter release() ;     static temporary_buffer aligned(size_t alignment, size_t size) ;     bool operator==(const temporary_buffer<char>& o) const ;     bool operator!=(const temporary_buffer<char>& o) const ; };
 }
  namespace seastar {
 template <typename char_type, typename Size, Size max_size, bool NulTerminate = true> class basic_sstring;
 using sstring = basic_sstring<char, uint32_t, 15>;
 template <typename string_type = sstring, typename T>  string_type to_sstring(T value);
 template <typename char_type, typename Size, Size max_size, bool NulTerminate> class basic_sstring {     static_assert(             (std::is_same<char_type, char>::value              || std::is_same<char_type, signed char>::value              || std::is_same<char_type, unsigned char>::value),             "basic_sstring only supports single byte char types");     union contents {         struct external_type {             char_type* str;             Size size;             int8_t pad;         } external;         struct internal_type {             char_type str[max_size];             int8_t size;         } internal;         static_assert(sizeof(external_type) <= sizeof(internal_type), "max_size too small");         static_assert(max_size <= 127, "max_size too large");     } u;     bool is_internal() const noexcept ;     bool is_external() const noexcept ;     const char_type* str() const ;     char_type* str() ;     template <typename string_type, typename T>     static string_type to_sstring_sprintf(T value, const char* fmt) ;     template <typename string_type>     static string_type to_sstring(int value) ;     template <typename string_type>     static string_type to_sstring(unsigned value) ;     template <typename string_type>     static string_type to_sstring(long value) ;     template <typename string_type>     static string_type to_sstring(unsigned long value) ;     template <typename string_type>     static string_type to_sstring(long long value) ;     template <typename string_type>     static string_type to_sstring(unsigned long long value) ;     template <typename string_type>     static string_type to_sstring(float value) ;     template <typename string_type>     static string_type to_sstring(double value) ;     template <typename string_type>     static string_type to_sstring(long double value) ;      ;      ;      ; public:     using value_type = char_type;     using traits_type = std::char_traits<char_type>;     using allocator_type = std::allocator<char_type>;     using reference = char_type&;     using const_reference = const char_type&;     using pointer = char_type*;     using const_pointer = const char_type*;     using iterator = char_type*;     using const_iterator = const char_type*;     using difference_type = ssize_t;       using size_type = Size;     static constexpr size_type  npos = static_cast<size_type>(-1);     static constexpr unsigned padding() ; public:     struct initialized_later {};                                                                                     operator std::basic_string<char_type>() const {         return { str(), size() };     }     size_t size() const noexcept {         return is_internal() ? u.internal.size : u.external.size;     }     size_t length() const noexcept {         return size();     }     size_t find(char_type t, size_t pos = 0) const noexcept {         const char_type* it = str() + pos;         const char_type* end = str() + size();         while (it < end) {             if (*it == t) {                 return it - str();             }             it++;         }         return npos;     }     size_t find(const basic_sstring& s, size_t pos = 0) const noexcept {         const char_type* it = str() + pos;         const char_type* end = str() + size();         const char_type* c_str = s.str();         const char_type* c_str_end = s.str() + s.size();         while (it < end) {             auto i = it;             auto j = c_str;             while ( i < end && j < c_str_end && *i == *j) {                 i++;                 j++;             }             if (j == c_str_end) {                 return it - str();             }             it++;         }         return npos;     }     size_t find_last_of (char_type c, size_t pos = npos) const noexcept {         const char_type* str_start = str();         if (size()) {             if (pos >= size()) {                 pos = size() - 1;             }             const char_type* p = str_start + pos + 1;             do {                 p--;                 if (*p == c) {                     return (p - str_start);                 }             } while (p != str_start);         }         return npos;     }     basic_sstring& append (const char_type* s, size_t n) {         basic_sstring ret(initialized_later(), size() + n);         std::copy(begin(), end(), ret.begin());         std::copy(s, s + n, ret.begin() + size());         *this = std::move(ret);         return *this;     }     void resize(size_t n, const char_type c  = '\0') {         if (n > size()) {             *this += basic_sstring(n - size(), c);         } else if (n < size()) {             if (is_internal()) {                 u.internal.size = n;                 if (NulTerminate) {                     u.internal.str[n] = '\0';                 }             } else if (n + padding() <= sizeof(u.internal.str)) {                 *this = basic_sstring(u.external.str, n);             } else {                 u.external.size = n;                 if (NulTerminate) {                     u.external.str[n] = '\0';                 }             }         }     }     basic_sstring& replace(size_type pos, size_type n1, const char_type* s,              size_type n2) {         if (pos > size()) {             throw std::out_of_range("sstring::replace out of range");         }         if (n1 > size() - pos) {             n1 = size() - pos;         }         if (n1 == n2) {             if (n2) {                 std::copy(s, s + n2, begin() + pos);             }             return *this;         }         basic_sstring ret(initialized_later(), size() + n2 - n1);         char_type* p= ret.begin();         std::copy(begin(), begin() + pos, p);         p += pos;         if (n2) {             std::copy(s, s + n2, p);         }         p += n2;         std::copy(begin() + pos + n1, end(), p);         *this = std::move(ret);         return *this;     }     template <class InputIterator>     basic_sstring& replace (const_iterator i1, const_iterator i2,             InputIterator first, InputIterator last) {         if (i1 < begin() || i1 > end() || i2 < begin()) {             throw std::out_of_range("sstring::replace out of range");         }         if (i2 > end()) {             i2 = end();         }         if (i2 - i1 == last - first) {             std::copy(first, last, const_cast<char_type*>(i1));             return *this;         }         basic_sstring ret(initialized_later(), size() + (last - first) - (i2 - i1));         char_type* p = ret.begin();         p = std::copy(cbegin(), i1, p);         p = std::copy(first, last, p);         std::copy(i2, cend(), p);         *this = std::move(ret);         return *this;     }     iterator erase(iterator first, iterator last) {         size_t pos = first - begin();         replace(pos, last - first, nullptr, 0);         return begin() + pos;     }     template <class InputIterator>     void insert(const_iterator p, InputIterator beg, InputIterator end) {         replace(p, p, beg, end);     }     reference     back() noexcept {         return operator[](size() - 1);     }     const_reference     back() const noexcept {         return operator[](size() - 1);     }     basic_sstring substr(size_t from, size_t len = npos)  const {         if (from > size()) {             throw std::out_of_range("sstring::substr out of range");         }         if (len > size() - from) {             len = size() - from;         }         if (len == 0) {             return "";         }         return { str() + from , len };     }     const char_type& at(size_t pos) const {         if (pos >= size()) {             throw std::out_of_range("sstring::at out of range");         }         return *(str() + pos);     }     char_type& at(size_t pos) {         if (pos >= size()) {             throw std::out_of_range("sstring::at out of range");         }         return *(str() + pos);     }     bool empty() const noexcept {         return u.internal.size == 0;     }     void reset() noexcept {         if (is_external()) {             std::free(u.external.str);         }         u.internal.size = 0;         if (NulTerminate) {             u.internal.str[0] = '\0';         }     }     temporary_buffer<char_type> release() && {         if (is_external()) {             auto ptr = u.external.str;             auto size = u.external.size;             u.external.str = nullptr;             u.external.size = 0;             return temporary_buffer<char_type>(ptr, size, make_free_deleter(ptr));         } else {             auto buf = temporary_buffer<char_type>(u.internal.size);             std::copy(u.internal.str, u.internal.str + u.internal.size, buf.get_write());             u.internal.size = 0;             if (NulTerminate) {                 u.internal.str[0] = '\0';             }             return buf;         }     }     int compare(const basic_sstring& x) const noexcept {         auto n = traits_type::compare(begin(), x.begin(), std::min(size(), x.size()));         if (n != 0) {             return n;         }         if (size() < x.size()) {             return -1;         } else if (size() > x.size()) {             return 1;         } else {             return 0;         }     }     int compare(size_t pos, size_t sz, const basic_sstring& x) const {         if (pos > size()) {             throw std::out_of_range("pos larger than string size");         }         sz = std::min(size() - pos, sz);         auto n = traits_type::compare(begin() + pos, x.begin(), std::min(sz, x.size()));         if (n != 0) {             return n;         }         if (sz < x.size()) {             return -1;         } else if (sz > x.size()) {             return 1;         } else {             return 0;         }     }     void swap(basic_sstring& x) noexcept {         contents tmp;         tmp = x.u;         x.u = u;         u = tmp;     }     char_type* data() {         return str();     }     const char_type* data() const {         return str();     }     const char_type* c_str() const {         return str();     }     const char_type* begin() const { return str(); }     const char_type* end() const { return str() + size(); }     const char_type* cbegin() const { return str(); }     const char_type* cend() const { return str() + size(); }     char_type* begin() { return str(); }     char_type* end() { return str() + size(); }     bool operator==(const basic_sstring& x) const {         return size() == x.size() && std::equal(begin(), end(), x.begin());     }     bool operator!=(const basic_sstring& x) const {         return !operator==(x);     }     bool operator<(const basic_sstring& x) const {         return compare(x) < 0;     }     basic_sstring operator+(const basic_sstring& x) const {         basic_sstring ret(initialized_later(), size() + x.size());         std::copy(begin(), end(), ret.begin());         std::copy(x.begin(), x.end(), ret.begin() + size());         return ret;     }     basic_sstring& operator+=(const basic_sstring& x) {         return *this = *this + x;     }     char_type& operator[](size_type pos) {         return str()[pos];     }     const char_type& operator[](size_type pos) const {         return str()[pos];     }     operator compat::basic_string_view<char_type>() const {         return compat::basic_string_view<char_type>(str(), size());     }     template <typename string_type, typename T>     friend inline string_type to_sstring(T value); };
 template <typename char_type, typename Size, Size max_size, bool NulTerminate> constexpr Size basic_sstring<char_type, Size, max_size, NulTerminate>::npos;
  ;
 }
  using namespace seastar;
#define GCC6_CONCEPT(x...)
GCC6_CONCEPT(template <typename H> concept bool Hasher() {
   return requires(H & h, const char *ptr, size_t size) {     { h.update(ptr, size) }     ->void;   };
 }
 ) template <typename T, typename Enable = void> struct appending_hash;
  namespace seastar {
 template<typename Pointer, typename Equal = std::equal_to<typename std::pointer_traits<Pointer>::element_type>> struct indirect_equal_to {     Equal _eq;     indirect_equal_to(Equal eq = Equal()) : _eq(std::move(eq)) {}     bool operator()(const Pointer& i1, const Pointer& i2) const {         if (bool(i1) ^ bool(i2)) {             return false;         }         return !i1 || _eq(*i1, *i2);     } };
 template<typename Pointer, typename Less = std::less<typename std::pointer_traits<Pointer>::element_type>> struct indirect_less {     Less _cmp;     indirect_less(Less cmp = Less()) : _cmp(std::move(cmp)) {}     bool operator()(const Pointer& i1, const Pointer& i2) const {         if (i1 && i2) {             return _cmp(*i1, *i2);         }         return !i1 && i2;     } };
 template<typename Pointer, typename Hash = std::hash<typename std::pointer_traits<Pointer>::element_type>> struct indirect_hash {     Hash _h;     indirect_hash(Hash h = Hash()) : _h(std::move(h)) {}     size_t operator()(const Pointer& p) const {         if (p) {             return _h(*p);         }         return 0;     } };
 }
 namespace seastar {
 using shared_ptr_counter_type = long;
 template <typename T> class lw_shared_ptr;
 template <typename T> class shared_ptr;
 template <typename T> class enable_lw_shared_from_this;
 template <typename T> class enable_shared_from_this;
 template <typename T, typename... A> lw_shared_ptr<T> make_lw_shared(A&&... a);
 ;
 ;
 struct lw_shared_ptr_counter_base {     shared_ptr_counter_type _count = 0; };
 namespace internal { template <class T, class U> struct lw_shared_ptr_accessors; template <class T> struct lw_shared_ptr_accessors_esft; template <class T> struct lw_shared_ptr_accessors_no_esft; }
 template <typename T> class enable_lw_shared_from_this : private lw_shared_ptr_counter_base {     using ctor = T; protected:                          public:     lw_shared_ptr<T> shared_from_this();     lw_shared_ptr<const T> shared_from_this() const;     template <typename X>     friend class lw_shared_ptr;     template <typename X>     friend struct internal::lw_shared_ptr_accessors_esft;     template <typename X, class Y>     friend struct internal::lw_shared_ptr_accessors; };
 template <typename T> struct shared_ptr_no_esft : private lw_shared_ptr_counter_base {     T _value;     shared_ptr_no_esft() = default;     shared_ptr_no_esft(const T& x) : _value(x) {}     shared_ptr_no_esft(T&& x) : _value(std::move(x)) {}     template <typename... A>     shared_ptr_no_esft(A&&... a) : _value(std::forward<A>(a)...) {}     template <typename X>     friend class lw_shared_ptr;     template <typename X>     friend struct internal::lw_shared_ptr_accessors_no_esft;     template <typename X, class Y>     friend struct internal::lw_shared_ptr_accessors; };
 template <typename T> struct lw_shared_ptr_deleter;
   namespace internal { template <typename T> struct lw_shared_ptr_accessors_esft {     using concrete_type = std::remove_const_t<T>;     static T* to_value(lw_shared_ptr_counter_base* counter) {         return static_cast<T*>(counter);     }     static void dispose(lw_shared_ptr_counter_base* counter) ;     static void dispose(T* value_ptr) ;      }; template <typename T> struct lw_shared_ptr_accessors_no_esft {     using concrete_type = shared_ptr_no_esft<T>;                     }; template <typename T, typename U = void> struct lw_shared_ptr_accessors : std::conditional_t<          std::is_base_of<enable_lw_shared_from_this<T>, T>::value,          lw_shared_ptr_accessors_esft<T>,          lw_shared_ptr_accessors_no_esft<T>> { }; template <typename... T> using void_t = void; template <typename T> struct lw_shared_ptr_accessors<T, void_t<decltype(lw_shared_ptr_deleter<T>{})>> {     using concrete_type = T;                }; }
 template <typename T> class lw_shared_ptr {     using accessors = internal::lw_shared_ptr_accessors<std::remove_const_t<T>>;     using concrete_type = typename accessors::concrete_type;     mutable lw_shared_ptr_counter_base* _p = nullptr; private:           ; public:     using element_type = T;          class disposer {     public:              };     lw_shared_ptr() noexcept = default;     lw_shared_ptr(std::nullptr_t) noexcept : lw_shared_ptr() {}     lw_shared_ptr(const lw_shared_ptr& x) noexcept : _p(x._p) {         if (_p) {             ++_p->_count;         }     }     lw_shared_ptr(lw_shared_ptr&& x) noexcept  : _p(x._p) {         x._p = nullptr;     }     [[gnu::always_inline]]     ~lw_shared_ptr() {         if (_p && !--_p->_count) {             accessors::dispose(_p);         }     }     lw_shared_ptr& operator=(const lw_shared_ptr& x) noexcept {         if (_p != x._p) {             this->~lw_shared_ptr();             new (this) lw_shared_ptr(x);         }         return *this;     }     lw_shared_ptr& operator=(lw_shared_ptr&& x) noexcept {         if (_p != x._p) {             this->~lw_shared_ptr();             new (this) lw_shared_ptr(std::move(x));         }         return *this;     }     lw_shared_ptr& operator=(std::nullptr_t) noexcept {         return *this = lw_shared_ptr();     }     lw_shared_ptr& operator=(T&& x) noexcept {         this->~lw_shared_ptr();         new (this) lw_shared_ptr(make_lw_shared<T>(std::move(x)));         return *this;     }     T& operator*() const noexcept { return *accessors::to_value(_p); }     T* operator->() const noexcept { return accessors::to_value(_p); }     T* get() const noexcept {         if (_p) {             return accessors::to_value(_p);         } else {             return nullptr;         }     }     std::unique_ptr<T, disposer> release() noexcept {         auto p = std::exchange(_p, nullptr);         if (--p->_count) {             return nullptr;         } else {             return std::unique_ptr<T, disposer>(accessors::to_value(p));         }     }     long int use_count() const noexcept {         if (_p) {             return _p->_count;         } else {             return 0;         }     }     operator lw_shared_ptr<const T>() const noexcept {         return lw_shared_ptr<const T>(_p);     }     explicit operator bool() const noexcept {         return _p;     }     bool owned() const noexcept {         return _p->_count == 1;     }     bool operator==(const lw_shared_ptr<const T>& x) const {         return _p == x._p;     }     bool operator!=(const lw_shared_ptr<const T>& x) const {         return !operator==(x);     }     bool operator==(const lw_shared_ptr<std::remove_const_t<T>>& x) const {         return _p == x._p;     }     bool operator!=(const lw_shared_ptr<std::remove_const_t<T>>& x) const {         return !operator==(x);     }     bool operator<(const lw_shared_ptr<const T>& x) const {         return _p < x._p;     }     bool operator<(const lw_shared_ptr<std::remove_const_t<T>>& x) const {         return _p < x._p;     }     template <typename U>     friend class lw_shared_ptr;     ;     ;     ;     template <typename U>     friend class enable_lw_shared_from_this; };
 template <typename T, typename... A> inline lw_shared_ptr<T> make_lw_shared(A&&... a) {     return lw_shared_ptr<T>::make(std::forward<A>(a)...); }
 template <typename T> inline lw_shared_ptr<T> make_lw_shared(T&& a) {     return lw_shared_ptr<T>::make(std::move(a)); }
 template <typename T> inline lw_shared_ptr<T> make_lw_shared(T& a) {     return lw_shared_ptr<T>::make(a); }
 template <typename T> inline lw_shared_ptr<T> enable_lw_shared_from_this<T>::shared_from_this() {     return lw_shared_ptr<T>(this); }
 template <typename T> inline lw_shared_ptr<const T> enable_lw_shared_from_this<T>::shared_from_this() const {     return lw_shared_ptr<const T>(const_cast<enable_lw_shared_from_this*>(this)); }
  struct shared_ptr_count_base {     virtual ~shared_ptr_count_base() {}     shared_ptr_counter_type count = 0; };
 template <typename T> struct shared_ptr_count_for : shared_ptr_count_base {     T data;      };
 template <typename T> class enable_shared_from_this : private shared_ptr_count_base { public:               template <typename U>     friend class shared_ptr;     template <typename U, bool esft>     friend struct shared_ptr_make_helper; };
 template <typename T> class shared_ptr {     mutable shared_ptr_count_base* _b = nullptr;     mutable T* _p = nullptr; private:          shared_ptr(shared_ptr_count_base* b, T* p)  ;     explicit shared_ptr(enable_shared_from_this<std::remove_const_t<T>>* p) noexcept : _b(p), _p(static_cast<T*>(p)) {         if (_b) {             ++_b->count;         }     } public:     using element_type = T;     shared_ptr() noexcept = default;     shared_ptr(std::nullptr_t) noexcept : shared_ptr() {}     shared_ptr(const shared_ptr& x) noexcept             : _b(x._b)             , _p(x._p) {         if (_b) {             ++_b->count;         }     }     shared_ptr(shared_ptr&& x) noexcept             : _b(x._b)             , _p(x._p) {         x._b = nullptr;         x._p = nullptr;     }     template <typename U, typename = std::enable_if_t<std::is_base_of<T, U>::value>>     shared_ptr(const shared_ptr<U>& x) noexcept             : _b(x._b)             , _p(x._p) {         if (_b) {             ++_b->count;         }     }     template <typename U, typename = std::enable_if_t<std::is_base_of<T, U>::value>>     shared_ptr(shared_ptr<U>&& x) noexcept             : _b(x._b)             , _p(x._p) {         x._b = nullptr;         x._p = nullptr;     }     ~shared_ptr() {         if (_b && !--_b->count) {             delete _b;         }     }     shared_ptr& operator=(const shared_ptr& x) noexcept {         if (this != &x) {             this->~shared_ptr();             new (this) shared_ptr(x);         }         return *this;     }     shared_ptr& operator=(shared_ptr&& x) noexcept {         if (this != &x) {             this->~shared_ptr();             new (this) shared_ptr(std::move(x));         }         return *this;     }     shared_ptr& operator=(std::nullptr_t) noexcept {         return *this = shared_ptr();     }     template <typename U, typename = std::enable_if_t<std::is_base_of<T, U>::value>>     shared_ptr& operator=(const shared_ptr<U>& x) noexcept {         if (*this != x) {             this->~shared_ptr();             new (this) shared_ptr(x);         }         return *this;     }     template <typename U, typename = std::enable_if_t<std::is_base_of<T, U>::value>>     shared_ptr& operator=(shared_ptr<U>&& x) noexcept {         if (*this != x) {             this->~shared_ptr();             new (this) shared_ptr(std::move(x));         }         return *this;     }     explicit operator bool() const noexcept {         return _p;     }     T& operator*() const noexcept {         return *_p;     }     T* operator->() const noexcept {         return _p;     }     T* get() const noexcept {         return _p;     }     long use_count() const noexcept {         if (_b) {             return _b->count;         } else {             return 0;         }     }     template <bool esft>     struct make_helper;     ;     ;     ;     ;     ;     ;     template <typename U>     friend class enable_shared_from_this;     template <typename U, bool esft>     friend struct shared_ptr_make_helper;     template <typename U>     friend class shared_ptr; };
 template <typename U, bool esft> struct shared_ptr_make_helper;
 template <typename T> struct shared_ptr_make_helper<T, false> {      ; };
 }
  using column_count_type = uint32_t;
  using column_id = column_count_type;
  class schema;
  using schema_ptr = seastar::lw_shared_ptr<const schema>;
  GCC6_CONCEPT(template <typename T> concept bool HasTriCompare =                  requires(const T &t) {
                    { t.compare(t) }
                    ->int;
                  }
 ) template <typename T> class with_relational_operators {
 private:   template <typename U>   GCC6_CONCEPT(requires HasTriCompare<U>)   int do_compare(const U &t) const;
 };
#include <experimental/type_traits>
namespace seastar {
 namespace stdx = std::experimental;
 GCC6_CONCEPT( template<typename T> concept bool OptimizableOptional() {     return stdx::is_default_constructible_v<T>         && stdx::is_nothrow_move_assignable_v<T>         && requires(const T& obj) {             { bool(obj) } noexcept;         }; }
 ) template<typename T> class optimized_optional {     T _object; public:     optimized_optional() = default;     optimized_optional(compat::nullopt_t) noexcept { }     optimized_optional(const T& obj) : _object(obj) { }     optimized_optional(T&& obj) noexcept : _object(std::move(obj)) { }     optimized_optional(compat::optional<T>&& obj) noexcept {         if (obj) {             _object = std::move(*obj);         }     }     optimized_optional(const optimized_optional&) = default;     optimized_optional(optimized_optional&&) = default;     optimized_optional& operator=(compat::nullopt_t) noexcept ;     template<typename U>     std::enable_if_t<std::is_same<std::decay_t<U>, T>::value, optimized_optional&>     operator=(U&& obj) noexcept {         _object = std::forward<U>(obj);         return *this;     }     optimized_optional& operator=(const optimized_optional&) = default;     optimized_optional& operator=(optimized_optional&&) = default;     explicit operator bool() const noexcept ;     T* operator->() noexcept ;     const T* operator->() const noexcept { return &_object; }     T& operator*() noexcept { return _object; }     const T& operator*() const noexcept { return _object; }     bool operator==(const optimized_optional& other) const {         return _object == other._object;     }     bool operator!=(const optimized_optional& other) const {         return _object != other._object;     }     friend std::ostream& operator<<(std::ostream& out, const optimized_optional& opt) {         if (!opt) {             return out << "null";         }         return out << *opt;     } };
 }
  using bytes = basic_sstring<int8_t, uint32_t, 31, false>;
  template <typename CharOutputIterator> GCC6_CONCEPT(requires requires(CharOutputIterator it) {
   *it++ = 'a';
   *it++ = 'a';
 }
 ) inline void serialize_string(CharOutputIterator &out, const char *s) {
   auto len = strlen(s);
   out = std::copy_n(s, len, out);
 }
  namespace utils {
 class UUID { private:   int64_t most_sig_bits;   int64_t least_sig_bits; public:   ; };
 }
   class abstract_type;
  using cql_protocol_version_type = uint8_t;
  class cql_serialization_format {
   cql_protocol_version_type _version;
 public:   static constexpr cql_protocol_version_type latest_version = 4;
   explicit cql_serialization_format(cql_protocol_version_type version)       : _version(version) {}
   static cql_serialization_format latest() {     return cql_serialization_format{latest_version};   }
   static cql_serialization_format internal() { return latest(); }
 };
  namespace utils {
 template <typename T, size_t N> class small_vector {   static_assert(N > 0);   static_assert(std::is_nothrow_move_constructible_v<T>);   static_assert(std::is_nothrow_move_assignable_v<T>);   static_assert(std::is_nothrow_destructible_v<T>); private:   T *_begin;   T *_end;   T *_capacity_end;   union internal {     internal();     ~internal();     T storage[N];   };   internal _internal; private:   bool uses_internal_storage() const noexcept {     return _begin == _internal.storage;   }   [[gnu::cold]] [[gnu::noinline]] void expand(size_t new_capacity) {     auto ptr =         static_cast<T *>(::aligned_alloc(alignof(T), new_capacity * sizeof(T)));     if (!ptr) {       throw std::bad_alloc();     }     auto n_end = std::uninitialized_move(begin(), end(), ptr);     std::destroy(begin(), end());     if (!uses_internal_storage()) {       std::free(_begin);     }     _begin = ptr;     _end = n_end;     _capacity_end = ptr + new_capacity;   }   [[gnu::cold]] [[gnu::noinline]] void   slow_copy_assignment(const small_vector &other) {     auto ptr =         static_cast<T *>(::aligned_alloc(alignof(T), other.size() * sizeof(T)));     if (!ptr) {       throw std::bad_alloc();     }     auto n_end = ptr;     try {       n_end = std::uninitialized_copy(other.begin(), other.end(), n_end);     } catch (...) {       std::free(ptr);       throw;     }     std::destroy(begin(), end());     if (!uses_internal_storage()) {       std::free(_begin);     }     _begin = ptr;     _end = n_end;     _capacity_end = n_end;   }   void reserve_at_least(size_t n) {     if (__builtin_expect(_begin + n > _capacity_end, false)) {       expand(std::max(n, capacity() * 2));     }   }   [[noreturn]] [[gnu::cold]] [[gnu::noinline]] void throw_out_of_range() {     throw std::out_of_range("out of range small vector access");   } public:   using value_type = T;   using pointer = T *;   using const_pointer = const T *;   using reference = T &;   using const_reference = const T &;   using iterator = T *;   using const_iterator = const T *;   using reverse_iterator = std::reverse_iterator<iterator>;   using const_reverse_iterator = std::reverse_iterator<const_iterator>;   small_vector() noexcept       : _begin(_internal.storage), _end(_begin), _capacity_end(_begin + N) {}   template <typename InputIterator>   small_vector(InputIterator first, InputIterator last) : small_vector() {     if constexpr (std::is_base_of_v<std::forward_iterator_tag,                                     typename std::iterator_traits<                                         InputIterator>::iterator_category>) {       reserve(std::distance(first, last));       _end = std::uninitialized_copy(first, last, _end);     } else {       std::copy(first, last, std::back_inserter(*this));     }   }   small_vector(std::initializer_list<T> list)       : small_vector(list.begin(), list.end()) {}   small_vector(small_vector &&other) noexcept {     if (other.uses_internal_storage()) {       _begin = _internal.storage;       _capacity_end = _begin + N;       if constexpr (std::is_trivially_copyable_v<T>) {         std::memcpy(_internal.storage, other._internal.storage, N * sizeof(T));         _end = _begin + other.size();       } else {         _end = _begin;         for (auto &e : other) {           new (_end++) T(std::move(e));           e.~T();         }       }       other._end = other._internal.storage;     } else {       _begin = std::exchange(other._begin, other._internal.storage);       _end = std::exchange(other._end, other._internal.storage);       _capacity_end =           std::exchange(other._capacity_end, other._internal.storage + N);     }   }   small_vector(const small_vector &other) noexcept : small_vector() {     reserve(other.size());     _end = std::uninitialized_copy(other.begin(), other.end(), _end);   }   small_vector &operator=(small_vector &&other) noexcept {     clear();     if (other.uses_internal_storage()) {       if (__builtin_expect(!uses_internal_storage(), false)) {         std::free(_begin);         _begin = _internal.storage;       }       _capacity_end = _begin + N;       if constexpr (std::is_trivially_copyable_v<T>) {         std::memcpy(_internal.storage, other._internal.storage, N * sizeof(T));         _end = _begin + other.size();       } else {         _end = _begin;         for (auto &e : other) {           new (_end++) T(std::move(e));           e.~T();         }       }       other._end = other._internal.storage;     } else {       if (__builtin_expect(!uses_internal_storage(), false)) {         std::free(_begin);       }       _begin = std::exchange(other._begin, other._internal.storage);       _end = std::exchange(other._end, other._internal.storage);       _capacity_end =           std::exchange(other._capacity_end, other._internal.storage + N);     }     return *this;   }   small_vector &operator=(const small_vector &other) {     if constexpr (std::is_nothrow_copy_constructible_v<T>) {       if (capacity() >= other.size()) {         clear();         _end = std::uninitialized_copy(other.begin(), other.end(), _end);         return *this;       }     }     slow_copy_assignment(other);     return *this;   }   ~small_vector() {     clear();     if (__builtin_expect(!uses_internal_storage(), false)) {       std::free(_begin);     }   }   void reserve(size_t n) {     if (__builtin_expect(_begin + n > _capacity_end, false)) {       expand(n);     }   }   void clear() noexcept {     std::destroy(_begin, _end);     _end = _begin;   }   iterator begin() noexcept { return _begin; }   const_iterator begin() const noexcept { return _begin; }   const_iterator cbegin() const noexcept { return _begin; }   iterator end() noexcept { return _end; }   const_iterator end() const noexcept { return _end; }   const_iterator cend() const noexcept { return _end; }   reverse_iterator rbegin() noexcept { return reverse_iterator(end()); }   const_reverse_iterator rbegin() const noexcept {     return const_reverse_iterator(end());   }   const_reverse_iterator crbegin() const noexcept {     return const_reverse_iterator(end());   }   reverse_iterator rend() noexcept { return reverse_iterator(begin()); }   const_reverse_iterator rend() const noexcept {     return const_reverse_iterator(begin());   }   const_reverse_iterator crend() const noexcept {     return const_reverse_iterator(begin());   }   T *data() noexcept { return _begin; }   const T *data() const noexcept { return _begin; }   T &front() noexcept { return *begin(); }   const T &front() const noexcept { return *begin(); }   T &back() noexcept { return end()[-1]; }   const T &back() const noexcept { return end()[-1]; }   T &operator[](size_t idx) noexcept { return data()[idx]; }   const T &operator[](size_t idx) const noexcept { return data()[idx]; }   T &at(size_t idx) {     if (__builtin_expect(idx >= size(), false)) {       throw_out_of_range();     }     return operator[](idx);   }   const T &at(size_t idx) const {     if (__builtin_expect(idx >= size(), false)) {       throw_out_of_range();     }     return operator[](idx);   }   bool empty() const noexcept { return _begin == _end; }   size_t size() const noexcept { return _end - _begin; }   size_t capacity() const noexcept { return _capacity_end - _begin; }   template <typename... Args> T &emplace_back(Args &&... args) {     if (__builtin_expect(_end == _capacity_end, false)) {       expand(std::max<size_t>(capacity() * 2, 1));     }     auto &ref = *new (_end) T(std::forward<Args>(args)...);     ++_end;     return ref;   }   T &push_back(const T &value) { return emplace_back(value); }   T &push_back(T &&value) { return emplace_back(std::move(value)); }   template <typename InputIterator>   iterator insert(const_iterator cpos, InputIterator first,                   InputIterator last) {     if constexpr (std::is_base_of_v<std::forward_iterator_tag,                                     typename std::iterator_traits<                                         InputIterator>::iterator_category>) {       if (first == last) {         return const_cast<iterator>(cpos);       }       auto idx = cpos - _begin;       auto new_count = std::distance(first, last);       reserve_at_least(size() + new_count);       auto pos = _begin + idx;       auto after = std::distance(pos, end());       if (__builtin_expect(pos == end(), true)) {         _end = std::uninitialized_copy(first, last, end());         return pos;       } else if (after > new_count) {         std::uninitialized_move(end() - new_count, end(), end());         std::move_backward(pos, end() - new_count, end());         try {           std::copy(first, last, pos);         } catch (...) {           std::move(pos + new_count, end() + new_count, pos);           std::destroy(end(), end() + new_count);           throw;         }       } else {         std::uninitialized_move(pos, end(), pos + new_count);         auto mid = std::next(first, after);         try {           std::uninitialized_copy(mid, last, end());           try {             std::copy(first, mid, pos);           } catch (...) {             std::destroy(end(), pos + new_count);             throw;           }         } catch (...) {           std::move(pos + new_count, end() + new_count, pos);           std::destroy(pos + new_count, end() + new_count);           throw;         }       }       _end += new_count;       return pos;     } else {       auto start = cpos - _begin;       auto idx = start;       while (first != last) {         try {           insert(begin() + idx, *first);           ++first;           ++idx;         } catch (...) {           erase(begin() + start, begin() + idx);           throw;         }       }       return begin() + idx;     }   }   template <typename... Args>   iterator emplace(const_iterator cpos, Args &&... args) {     auto idx = cpos - _begin;     reserve_at_least(size() + 1);     auto pos = _begin + idx;     if (pos != _end) {       new (_end) T(std::move(_end[-1]));       std::move_backward(pos, _end - 1, _end);       pos->~T();     }     try {       new (pos) T(std::forward<Args>(args)...);     } catch (...) {       if (pos != _end) {         new (pos) T(std::move(pos[1]));         std::move(pos + 2, _end + 1, pos + 1);         _end->~T();       }       throw;     }     _end++;     return pos;   }   iterator insert(const_iterator cpos, const T &obj) {     return emplace(cpos, obj);   }   iterator insert(const_iterator cpos, T &&obj) {     return emplace(cpos, std::move(obj));   }   void resize(size_t n) {     if (n < size()) {       erase(end() - (size() - n), end());     } else if (n > size()) {       reserve_at_least(n);       _end = std::uninitialized_value_construct_n(_end, n - size());     }   }   void resize(size_t n, const T &value) {     if (n < size()) {       erase(end() - (size() - n), end());     } else if (n > size()) {       reserve_at_least(n);       auto nend = _begin + n;       std::uninitialized_fill(_end, nend, value);       _end = nend;     }   }   void pop_back() noexcept { (--_end)->~T(); }   iterator erase(const_iterator cit) noexcept { return erase(cit, cit + 1); }   iterator erase(const_iterator cfirst, const_iterator clast) noexcept {     auto first = const_cast<iterator>(cfirst);     auto last = const_cast<iterator>(clast);     std::move(last, end(), first);     auto nend = _end - (clast - cfirst);     std::destroy(nend, _end);     _end = nend;     return first;   }   void swap(small_vector &other) noexcept { std::swap(*this, other); }   bool operator==(const small_vector &other) const noexcept {     return size() == other.size() && std::equal(_begin, _end, other.begin());   }   bool operator!=(const small_vector &other) const noexcept {     return !(*this == other);   } };
 }
#include <arpa/inet.h>  
 namespace seastar {
 template <typename Func, typename Args, typename IndexList> struct apply_helper;
 template <typename Func, typename Tuple, size_t... I> struct apply_helper<Func, Tuple, std::index_sequence<I...>> {     static auto apply(Func&& func, Tuple args) {         return func(std::get<I>(std::forward<Tuple>(args))...);     } };
   template <typename Func, typename... T> inline auto apply(Func&& func, const std::tuple<T...>& args) {     using helper = apply_helper<Func, const std::tuple<T...>&, std::index_sequence_for<T...>>;     return helper::apply(std::forward<Func>(func), args); }
 }
#include <typeindex>
namespace seastar {
 template<typename T> struct function_traits;
 template<typename Ret, typename... Args> struct function_traits<Ret(Args...)> {     using return_type = Ret;     using args_as_tuple = std::tuple<Args...>;     using signature = Ret (Args...);     static constexpr std::size_t arity = sizeof...(Args);     template <std::size_t N>     struct arg     {         static_assert(N < arity, "no such parameter index.");         using type = typename std::tuple_element<N, std::tuple<Args...>>::type;     }; };
 template<typename Ret, typename... Args> struct function_traits<Ret(*)(Args...)> : public function_traits<Ret(Args...)> {};
 template <typename T, typename Ret, typename... Args> struct function_traits<Ret(T::*)(Args...)> : public function_traits<Ret(Args...)> {};
 template <typename T, typename Ret, typename... Args> struct function_traits<Ret(T::*)(Args...) const> : public function_traits<Ret(Args...)> {};
 template <typename... T> class future;
 class reactor;
 class scheduling_group;
 namespace internal { unsigned scheduling_group_index(scheduling_group sg);  }
    struct scheduling_group_key_config {               size_t allocation_size;     size_t alignment;     std::type_index type_index;     std::function<void (void*)> constructor;     std::function<void (void*)> destructor; };
 class scheduling_group_key { public:      private:          unsigned long _id;          friend class reactor;          ;     ; };
 namespace internal {  }
   ;
 class scheduling_group {     unsigned _id; private:      public:     constexpr scheduling_group() noexcept : _id(0) {}      ;          bool operator==(scheduling_group x) const ;          bool is_main() const ;     template<typename T>     T& get_specific(scheduling_group_key key) ;     void set_shares(float shares);     friend future<scheduling_group> create_scheduling_group(sstring name, float shares);          friend future<> rename_scheduling_group(scheduling_group sg, sstring new_name);     friend class reactor;     friend unsigned internal::scheduling_group_index(scheduling_group sg);          template<typename SpecificValType, typename Mapper, typename Reducer, typename Initial>     GCC6_CONCEPT( requires requires(SpecificValType specific_val, Mapper mapper, Reducer reducer, Initial initial) {         {reducer(initial, mapper(specific_val))} -> Initial;     })     friend future<typename function_traits<Reducer>::return_type>     map_reduce_scheduling_group_specific(Mapper mapper, Reducer reducer, Initial initial_val, scheduling_group_key key);     template<typename SpecificValType, typename Reducer, typename Initial>     GCC6_CONCEPT( requires requires(SpecificValType specific_val, Reducer reducer, Initial initial) {         {reducer(initial, specific_val)} -> Initial;     })     friend future<typename function_traits<Reducer>::return_type>         reduce_scheduling_group_specific(Reducer reducer, Initial initial_val, scheduling_group_key key); };
 namespace internal {  unsigned scheduling_group_index(scheduling_group sg) ;    scheduling_group* current_scheduling_group_ptr() ; }
 inline scheduling_group current_scheduling_group() {     return *internal::current_scheduling_group_ptr(); }
 inline scheduling_group default_scheduling_group() {     return scheduling_group(); }
  }
  namespace seastar {
 class task {     scheduling_group _sg; protected:     ~task() = default; public:     explicit task(scheduling_group sg = current_scheduling_group()) : _sg(sg) {}     virtual void run_and_dispose() noexcept = 0;     scheduling_group group() const { return _sg; } };
 void schedule(task* t) noexcept;
 void schedule_urgent(task* t) noexcept;
 template <typename Func> class lambda_task final : public task {     Func _func; public:     lambda_task(scheduling_group sg, const Func& func) : task(sg), _func(func) {}     lambda_task(scheduling_group sg, Func&& func) : task(sg), _func(std::move(func)) {}     virtual void run_and_dispose() noexcept override {         _func();         delete this;     } };
 template <typename Func> inline task* make_task(Func&& func) noexcept {     return new lambda_task<Func>(current_scheduling_group(), std::forward<Func>(func)); }
 template <typename Func> inline task* make_task(scheduling_group sg, Func&& func) noexcept {     return new lambda_task<Func>(sg, std::forward<Func>(func)); }
 }
  namespace seastar {
 namespace internal { struct preemption_monitor {     std::atomic<uint32_t> head;     std::atomic<uint32_t> tail; }; }
 extern __thread const internal::preemption_monitor* g_need_preempt;
 inline bool need_preempt() noexcept {     std::atomic_signal_fence(std::memory_order_seq_cst);     auto np = g_need_preempt;     auto head = np->head.load(std::memory_order_relaxed);     auto tail = np->tail.load(std::memory_order_relaxed);     return __builtin_expect(head != tail, false); }
 }
#include <setjmp.h>
#include <ucontext.h>
namespace seastar {
 using thread_clock = std::chrono::steady_clock;
 class thread_context;
 class scheduling_group;
 struct jmp_buf_link {     jmp_buf jmpbuf;     jmp_buf_link* link;     thread_context* thread; public:     void initial_switch_in(ucontext_t* initial_context, const void* stack_bottom, size_t stack_size);     void switch_in();     void switch_out();     void initial_switch_in_completed();     void final_switch_out(); };
 extern thread_local jmp_buf_link* g_current_context;
 namespace thread_impl { inline thread_context* get() {     return g_current_context->thread; }  bool should_yield() ; scheduling_group sched_group(const thread_context*); void yield(); void switch_in(thread_context* to); void switch_out(thread_context* from); void init(); }
 }
#include <assert.h>
namespace seastar {
 namespace internal { template<typename T> struct used_size {     static constexpr size_t value = std::is_empty<T>::value ? 0 : sizeof(T); }; }
 }
  namespace seastar {
 template <typename Signature> class noncopyable_function;
 namespace internal { class noncopyable_function_base { private:     noncopyable_function_base() = default;     static constexpr size_t nr_direct = 32;     union [[gnu::may_alias]] storage {         char direct[nr_direct];         void* indirect;     };     using move_type = void (*)(noncopyable_function_base* from, noncopyable_function_base* to);     using destroy_type = void (*)(noncopyable_function_base* func);     static void empty_move(noncopyable_function_base* from, noncopyable_function_base* to) ;     static void empty_destroy(noncopyable_function_base* func) ;     static void indirect_move(noncopyable_function_base* from, noncopyable_function_base* to) ;     template <size_t N>     static void trivial_direct_move(noncopyable_function_base* from, noncopyable_function_base* to) ;     static void trivial_direct_destroy(noncopyable_function_base* func) ; private:     storage _storage;     template <typename Signature>     friend class seastar::noncopyable_function; }; }
 template <typename Ret, typename... Args> class noncopyable_function<Ret (Args...)> : private internal::noncopyable_function_base {     using call_type = Ret (*)(const noncopyable_function* func, Args...);     struct vtable {         const call_type call;         const move_type move;         const destroy_type destroy;     }; private:     const vtable* _vtable; private:     static Ret empty_call(const noncopyable_function* func, Args... args) ;     static constexpr vtable _s_empty_vtable = {empty_call, empty_move, empty_destroy};     template <typename Func>     struct direct_vtable_for {         static Func* access(noncopyable_function* func) { return reinterpret_cast<Func*>(func->_storage.direct); }         static const Func* access(const noncopyable_function* func) { return reinterpret_cast<const Func*>(func->_storage.direct); }         static Func* access(noncopyable_function_base* func) { return access(static_cast<noncopyable_function*>(func)); }         static Ret call(const noncopyable_function* func, Args... args) {             return (*access(const_cast<noncopyable_function*>(func)))(std::forward<Args>(args)...);         }         static void move(noncopyable_function_base* from, noncopyable_function_base* to) {             new (access(to)) Func(std::move(*access(from)));             destroy(from);         }         static constexpr move_type select_move_thunk() {             bool can_trivially_move = std::is_trivially_move_constructible<Func>::value                     && std::is_trivially_destructible<Func>::value;             return can_trivially_move ? trivial_direct_move<internal::used_size<Func>::value> : move;         }         static void destroy(noncopyable_function_base* func) {             access(func)->~Func();         }         static constexpr destroy_type select_destroy_thunk() {             return std::is_trivially_destructible<Func>::value ? trivial_direct_destroy : destroy;         }         static void initialize(Func&& from, noncopyable_function* to) {             new (access(to)) Func(std::move(from));         }         static constexpr vtable make_vtable() { return { call, select_move_thunk(), select_destroy_thunk() }; }         static const vtable s_vtable;     };     template <typename Func>     struct indirect_vtable_for {         static Func* access(noncopyable_function* func) { return reinterpret_cast<Func*>(func->_storage.indirect); }         static const Func* access(const noncopyable_function* func) { return reinterpret_cast<const Func*>(func->_storage.indirect); }         static Func* access(noncopyable_function_base* func) { return access(static_cast<noncopyable_function*>(func)); }         static Ret call(const noncopyable_function* func, Args... args) {             return (*access(const_cast<noncopyable_function*>(func)))(std::forward<Args>(args)...);         }         static void destroy(noncopyable_function_base* func) {             delete access(func);         }         static void initialize(Func&& from, noncopyable_function* to) {             to->_storage.indirect = new Func(std::move(from));         }         static constexpr vtable make_vtable() { return { call, indirect_move, destroy }; }         static const vtable s_vtable;     };     template <typename Func, bool Direct = true>     struct select_vtable_for : direct_vtable_for<Func> {};     template <typename Func>     struct select_vtable_for<Func, false> : indirect_vtable_for<Func> {};     template <typename Func>     static constexpr bool is_direct() {         return sizeof(Func) <= nr_direct && alignof(Func) <= alignof(storage)                 && std::is_nothrow_move_constructible<Func>::value;     }     template <typename Func>     struct vtable_for : select_vtable_for<Func, is_direct<Func>()> {}; public:     noncopyable_function() noexcept : _vtable(&_s_empty_vtable) {}     template <typename Func>     noncopyable_function(Func func) {         vtable_for<Func>::initialize(std::move(func), this);         _vtable = &vtable_for<Func>::s_vtable;     }     template <typename Object, typename... AllButFirstArg>     noncopyable_function(Ret (Object::*member)(AllButFirstArg...)) : noncopyable_function(std::mem_fn(member)) {}                                         };
 template <typename Ret, typename... Args> constexpr typename noncopyable_function<Ret (Args...)>::vtable noncopyable_function<Ret (Args...)>::_s_empty_vtable;
 template <typename Ret, typename... Args> template <typename Func> const typename noncopyable_function<Ret (Args...)>::vtable noncopyable_function<Ret (Args...)>::direct_vtable_for<Func>::s_vtable         = noncopyable_function<Ret (Args...)>::direct_vtable_for<Func>::make_vtable();
 template <typename Ret, typename... Args> template <typename Func> const typename noncopyable_function<Ret (Args...)>::vtable noncopyable_function<Ret (Args...)>::indirect_vtable_for<Func>::s_vtable         = noncopyable_function<Ret (Args...)>::indirect_vtable_for<Func>::make_vtable();
 }
  namespace seastar {
 namespace memory { class alloc_failure_injector {     uint64_t _alloc_count;     uint64_t _fail_at = std::numeric_limits<uint64_t>::max();     noncopyable_function<void()> _on_alloc_failure = [] { throw std::bad_alloc(); };     bool _failed;     uint64_t _suppressed = 0;     friend struct disable_failure_guard; private:      public:                               }; extern thread_local alloc_failure_injector the_alloc_failure_injector;   struct disable_failure_guard {     ~disable_failure_guard() ; };   }
 }
#define SEASTAR_NODISCARD [[nodiscard]]
namespace seastar {
 template <class... T> class promise;
 template <class... T> class future;
 template <typename... T> class shared_future;
 struct future_state_base;
 template <typename... T, typename... A> future<T...> make_ready_future(A&&... value);
 ;
  ;
  ;
 void engine_exit(std::exception_ptr eptr = {}
);
 void report_failed_future(const std::exception_ptr& ex) noexcept;
 void report_failed_future(const future_state_base& state) noexcept;
 struct broken_promise : std::logic_error {     broken_promise(); };
 namespace internal { template <class... T> class promise_base_with_type; template <typename... T> future<T...> current_exception_as_future() noexcept; extern template future<> current_exception_as_future() noexcept; template <typename... T> struct get0_return_type {     using type = void;     static type get0(std::tuple<T...> v) ; }; template <typename T0, typename... T> struct get0_return_type<T0, T...> {     using type = T0;     static type get0(std::tuple<T0, T...> v) ; }; template <typename T, bool is_trivial_class> struct uninitialized_wrapper_base; template <typename T> struct uninitialized_wrapper_base<T, false> {     union any {         any() ;         ~any() ;         T value;     } _v; public:     void uninitialized_set(T&& v) ;     T& uninitialized_get() ;     const T& uninitialized_get() const ; }; template <typename T> struct uninitialized_wrapper_base<T, true> : private T {     void uninitialized_set(T&& v) ;     T& uninitialized_get() ;     const T& uninitialized_get() const ; }; template <typename T> constexpr bool can_inherit =         std::is_same<std::tuple<>, T>::value ||         (std::is_trivially_destructible<T>::value && std::is_trivially_constructible<T>::value &&                 std::is_class<T>::value && !std::is_final<T>::value); template <typename T> struct uninitialized_wrapper     : public uninitialized_wrapper_base<T, can_inherit<T>> {}; static_assert(std::is_empty<uninitialized_wrapper<std::tuple<>>>::value, "This should still be empty"); template <typename T> struct is_trivially_move_constructible_and_destructible {     static constexpr bool value = std::is_trivially_move_constructible<T>::value && std::is_trivially_destructible<T>::value; }; template <bool... v> struct all_true : std::false_type {}; template <> struct all_true<> : std::true_type {}; template <bool... v> struct all_true<true, v...> : public all_true<v...> {}; }
 struct future_state_base {     static_assert(std::is_nothrow_copy_constructible<std::exception_ptr>::value,                   "std::exception_ptr's copy constructor must not throw");     static_assert(std::is_nothrow_move_constructible<std::exception_ptr>::value,                   "std::exception_ptr's move constructor must not throw");     static_assert(sizeof(std::exception_ptr) == sizeof(void*), "exception_ptr not a pointer");     enum class state : uintptr_t {          invalid = 0,          future = 1,          result_unavailable = 2,          result = 3,          exception_min = 4,       };     union any {         any() ;         any(state s) ;         void set_exception(std::exception_ptr&& e) ;         any(std::exception_ptr&& e) {             set_exception(std::move(e));         }         ~any() {}         std::exception_ptr take_exception() {             std::exception_ptr ret(std::move(ex));             ex.~exception_ptr();             st = state::invalid;             return ret;         }         any(any&& x) {             if (x.st < state::exception_min) {                 st = x.st;                 x.st = state::invalid;             } else {                 new (&ex) std::exception_ptr(x.take_exception());             }         }         bool has_result() const {             return st == state::result || st == state::result_unavailable;         }         state st;         std::exception_ptr ex;     } _u;     future_state_base() noexcept { }     future_state_base(state st) noexcept : _u(st) { }     future_state_base(std::exception_ptr&& ex) noexcept : _u(std::move(ex)) { }     future_state_base(future_state_base&& x) noexcept : _u(std::move(x._u)) { } protected:     ~future_state_base() noexcept {         if (failed()) {             report_failed_future(_u.take_exception());         }     } public:     bool valid() const noexcept { return _u.st != state::invalid; }     bool available() const noexcept { return _u.st == state::result || _u.st >= state::exception_min; }     bool failed() const noexcept ;     void set_to_broken_promise() noexcept;     void ignore() noexcept ;     void set_exception(std::exception_ptr&& ex) noexcept ;     future_state_base& operator=(future_state_base&& x) noexcept ;     void set_exception(future_state_base&& state) noexcept ;     std::exception_ptr get_exception() && noexcept ;     const std::exception_ptr& get_exception() const& noexcept ;     static future_state_base current_exception();     template <typename... U>     friend future<U...> internal::current_exception_as_future() noexcept; };
 struct ready_future_marker {};
 struct exception_future_marker {};
 struct future_for_get_promise_marker {};
 template <typename... T> struct future_state :  public future_state_base, private internal::uninitialized_wrapper<std::tuple<T...>> {     static constexpr bool copy_noexcept = std::is_nothrow_copy_constructible<std::tuple<T...>>::value;     static constexpr bool has_trivial_move_and_destroy =         internal::all_true<internal::is_trivially_move_constructible_and_destructible<T>::value...>::value;     static_assert(std::is_nothrow_move_constructible<std::tuple<T...>>::value,                   "Types must be no-throw move constructible");     static_assert(std::is_nothrow_destructible<std::tuple<T...>>::value,                   "Types must be no-throw destructible");     future_state() noexcept {}     [[gnu::always_inline]]     future_state(future_state&& x) noexcept : future_state_base(std::move(x)) {         if (has_trivial_move_and_destroy) {             memcpy(reinterpret_cast<char*>(&this->uninitialized_get()),                    &x.uninitialized_get(),                    internal::used_size<std::tuple<T...>>::value);         } else if (_u.has_result()) {             this->uninitialized_set(std::move(x.uninitialized_get()));             x.uninitialized_get().~tuple();         }     }     __attribute__((always_inline))     ~future_state() noexcept {         if (_u.has_result()) {             this->uninitialized_get().~tuple();         }     }     future_state& operator=(future_state&& x) noexcept {         this->~future_state();         new (this) future_state(std::move(x));         return *this;     }     template <typename... A>     future_state(ready_future_marker, A&&... a) : future_state_base(state::result) {         this->uninitialized_set(std::tuple<T...>(std::forward<A>(a)...));     }     template <typename... A>     void set(A&&... a) {         assert(_u.st == state::future);         new (this) future_state(ready_future_marker(), std::forward<A>(a)...);     }     future_state(exception_future_marker m, std::exception_ptr&& ex) : future_state_base(std::move(ex)) { }     future_state(exception_future_marker m, future_state_base&& state) : future_state_base(std::move(state)) { }     std::tuple<T...>&& get_value() && noexcept {         assert(_u.st == state::result);         return std::move(this->uninitialized_get());     }     std::tuple<T...>&& take_value() && noexcept {         assert(_u.st == state::result);         _u.st = state::result_unavailable;         return std::move(this->uninitialized_get());     }     template<typename U = std::tuple<T...>>     const std::enable_if_t<std::is_copy_constructible<U>::value, U>& get_value() const& noexcept(copy_noexcept) {         assert(_u.st == state::result);         return this->uninitialized_get();     }     std::tuple<T...>&& take() && {         assert(available());         if (_u.st >= state::exception_min) {             std::rethrow_exception(std::move(*this).get_exception());         }         _u.st = state::result_unavailable;         return std::move(this->uninitialized_get());     }     std::tuple<T...>&& get() && {         assert(available());         if (_u.st >= state::exception_min) {             std::rethrow_exception(std::move(*this).get_exception());         }         return std::move(this->uninitialized_get());     }     const std::tuple<T...>& get() const& {         assert(available());         if (_u.st >= state::exception_min) {             std::rethrow_exception(_u.ex);         }         return this->uninitialized_get();     }     using get0_return_type = typename internal::get0_return_type<T...>::type;     static get0_return_type get0(std::tuple<T...>&& x) {         return internal::get0_return_type<T...>::get0(std::move(x));     } };
 static_assert(sizeof(future_state<>) <= 8, "future_state<> is too large");
 static_assert(sizeof(future_state<long>) <= 16, "future_state<long> is too large");
 template <typename... T> class continuation_base : public task { protected:     future_state<T...> _state;     using future_type = future<T...>;     using promise_type = promise<T...>; public:     continuation_base() = default;     explicit continuation_base(future_state<T...>&& state) : _state(std::move(state)) {}     void set_state(future_state<T...>&& state) {         _state = std::move(state);     }     friend class internal::promise_base_with_type<T...>;     friend class promise<T...>;     friend class future<T...>; };
 template <typename Func, typename... T> struct continuation final : continuation_base<T...> {     continuation(Func&& func, future_state<T...>&& state) : continuation_base<T...>(std::move(state)), _func(std::move(func)) {}     continuation(Func&& func) : _func(std::move(func)) {}     virtual void run_and_dispose() noexcept override {         _func(std::move(this->_state));         delete this;     }     Func _func; };
 namespace internal { template <typename... T> future<T...> make_exception_future(future_state_base&& state) noexcept; template <typename... T, typename U> void set_callback(future<T...>& fut, U* callback) noexcept; class future_base; class promise_base { protected:     enum class urgent { no, yes };     future_base* _future = nullptr;     future_state_base* _state;     task* _task = nullptr;     promise_base(const promise_base&) = delete;     promise_base(future_state_base* state) noexcept : _state(state) {}     promise_base(future_base* future, future_state_base* state) noexcept;     promise_base(promise_base&& x) noexcept;     ~promise_base() noexcept;     void operator=(const promise_base&) = delete;     promise_base& operator=(promise_base&& x) = delete;     template<urgent Urgent>     void make_ready() noexcept;     template<typename T>     void set_exception_impl(T&& val) noexcept ;     void set_exception(future_state_base&& state) noexcept ;     void set_exception(std::exception_ptr&& ex) noexcept ;     void set_exception(const std::exception_ptr& ex) noexcept ;     template<typename Exception>     std::enable_if_t<!std::is_same<std::remove_reference_t<Exception>, std::exception_ptr>::value, void> set_exception(Exception&& e) noexcept {         set_exception(make_exception_ptr(std::forward<Exception>(e)));     }     friend class future_base;     template <typename... U> friend class seastar::future; }; template <typename... T> class promise_base_with_type : protected internal::promise_base { protected:     future_state<T...>* get_state() ;     static constexpr bool copy_noexcept = future_state<T...>::copy_noexcept; public:     promise_base_with_type(future_state_base* state)  ;     promise_base_with_type(future<T...>* future)  ;     promise_base_with_type(promise_base_with_type&& x) noexcept : promise_base(std::move(x)) { }     promise_base_with_type(const promise_base_with_type&) = delete;     promise_base_with_type& operator=(promise_base_with_type&& x) noexcept {         this->~promise_base_with_type();         new (this) promise_base_with_type(std::move(x));         return *this;     }     void operator=(const promise_base_with_type&) = delete;     void set_urgent_state(future_state<T...>&& state) noexcept {         if (_state) {             *get_state() = std::move(state);             make_ready<urgent::yes>();         }     }     template <typename... A>     void set_value(A&&... a) {         if (auto *s = get_state()) {             s->set(std::forward<A>(a)...);             make_ready<urgent::no>();         }     } private:     template <typename Func>     void schedule(Func&& func) noexcept {         auto tws = new continuation<Func, T...>(std::move(func));         _state = &tws->_state;         _task = tws;     }     void schedule(continuation_base<T...>* callback) noexcept {         _state = &callback->_state;         _task = callback;     }     template <typename... U>     friend class seastar::future;     friend struct seastar::future_state<T...>; }; }
 template <typename... T> class promise : private internal::promise_base_with_type<T...> {     future_state<T...> _local_state; public:     promise()  ;     promise(promise&& x) noexcept;     promise(const promise&) = delete;     promise& operator=(promise&& x) noexcept ;     void operator=(const promise&) = delete;     future<T...> get_future() noexcept;     template <typename... A>     void set_value(A&&... a) ;     void set_exception(std::exception_ptr&& ex) noexcept ;     void set_exception(const std::exception_ptr& ex) noexcept ;     template<typename Exception>     std::enable_if_t<!std::is_same<std::remove_reference_t<Exception>, std::exception_ptr>::value, void> set_exception(Exception&& e) noexcept {         internal::promise_base::set_exception(std::forward<Exception>(e));     }     using internal::promise_base_with_type<T...>::set_urgent_state;     template <typename... U>     friend class future; };
 template<> class promise<void> : public promise<> {};
 template <typename... T> struct is_future : std::false_type {};
 template <typename... T> struct is_future<future<T...>> : std::true_type {};
 template <typename T> struct futurize;
 template <typename T> struct futurize {     using type = future<T>;     using promise_type = promise<T>;     using value_type = std::tuple<T>;     template<typename Func, typename... FuncArgs>     static inline type apply(Func&& func, std::tuple<FuncArgs...>&& args) noexcept;     template<typename Func, typename... FuncArgs>     static inline type apply(Func&& func, FuncArgs&&... args) noexcept;     static type convert(T&& value) ;     static type convert(type&& value) ;     static type from_tuple(value_type&& value);     static type from_tuple(const value_type& value);     template <typename Arg>     static type make_exception_future(Arg&& arg); };
 template <> struct futurize<void> {     using type = future<>;     using promise_type = promise<>;     using value_type = std::tuple<>;     template<typename Func, typename... FuncArgs>     static inline type apply(Func&& func, std::tuple<FuncArgs...>&& args) noexcept;     template<typename Func, typename... FuncArgs>     static inline type apply(Func&& func, FuncArgs&&... args) noexcept;     static inline type from_tuple(value_type&& value);     static inline type from_tuple(const value_type& value);     template <typename Arg>     static type make_exception_future(Arg&& arg); };
 template <typename... Args> struct futurize<future<Args...>> {     using type = future<Args...>;     using promise_type = promise<Args...>;     using value_type = std::tuple<Args...>;     template<typename Func, typename... FuncArgs>     static inline type apply(Func&& func, std::tuple<FuncArgs...>&& args) noexcept;     template<typename Func, typename... FuncArgs>     static inline type apply(Func&& func, FuncArgs&&... args) noexcept;     static inline type from_tuple(value_type&& value);     static inline type from_tuple(const value_type& value);     static inline type convert(Args&&... values) { return make_ready_future<Args...>(std::move(values)...); }     static inline type convert(type&& value) { return std::move(value); }     template <typename Arg>     static type make_exception_future(Arg&& arg); };
 template <typename T> using futurize_t = typename futurize<T>::type;
 GCC6_CONCEPT( template <typename T> concept bool Future = is_future<T>::value;
 template <typename Func, typename... T> concept bool CanApply = requires (Func f, T... args) {     f(std::forward<T>(args)...); };
 template <typename Func, typename Return, typename... T> concept bool ApplyReturns = requires (Func f, T... args) {     { f(std::forward<T>(args)...) } -> Return; };
 template <typename Func, typename... T> concept bool ApplyReturnsAnyFuture = requires (Func f, T... args) {     requires is_future<decltype(f(std::forward<T>(args)...))>::value; };
 ) namespace internal { class future_base { protected:     promise_base* _promise;     future_base() noexcept : _promise(nullptr) {}     future_base(promise_base* promise, future_state_base* state)  ;     future_base(future_base&& x, future_state_base* state)  ;     ~future_base() noexcept ;     promise_base* detach_promise() noexcept ;     friend class promise_base; }; template <bool IsVariadic> struct warn_variadic_future {     void check_deprecation() ; }; template <> struct warn_variadic_future<true> {     [[deprecated("Variadic future<> with more than one template parmeter is deprecated, replace with future<std::tuple<...>>")]]     void check_deprecation() {} }; }
 template <typename... T> class SEASTAR_NODISCARD future : private internal::future_base, internal::warn_variadic_future<(sizeof...(T) > 1)> {     future_state<T...> _state;     static constexpr bool copy_noexcept = future_state<T...>::copy_noexcept; private:     future(future_for_get_promise_marker m) { }     future(promise<T...>* pr) noexcept : future_base(pr, &_state), _state(std::move(pr->_local_state)) { }     template <typename... A>     future(ready_future_marker m, A&&... a) : _state(m, std::forward<A>(a)...) { }     future(exception_future_marker m, std::exception_ptr&& ex) noexcept : _state(m, std::move(ex)) { }     future(exception_future_marker m, future_state_base&& state) noexcept : _state(m, std::move(state)) { }     [[gnu::always_inline]]     explicit future(future_state<T...>&& state) noexcept             : _state(std::move(state)) {         this->check_deprecation();     }     internal::promise_base_with_type<T...> get_promise() noexcept {         assert(!_promise);         return internal::promise_base_with_type<T...>(this);     }     internal::promise_base_with_type<T...>* detach_promise() {         return static_cast<internal::promise_base_with_type<T...>*>(future_base::detach_promise());     }     template <typename Func>     void schedule(Func&& func) noexcept {         if (_state.available() || !_promise) {             if (__builtin_expect(!_state.available() && !_promise, false)) {                 _state.set_to_broken_promise();             }             ::seastar::schedule(new continuation<Func, T...>(std::move(func), std::move(_state)));         } else {             assert(_promise);             detach_promise()->schedule(std::move(func));             _state._u.st = future_state_base::state::invalid;         }     }     [[gnu::always_inline]]     future_state<T...>&& get_available_state_ref() noexcept {         if (_promise) {             detach_promise();         }         return std::move(_state);     }     [[gnu::noinline]]     future<T...> rethrow_with_nested() {         if (!failed()) {             return internal::current_exception_as_future<T...>();         } else {             std::nested_exception f_ex;             try {                 get();             } catch (...) {                 std::throw_with_nested(f_ex);             }             __builtin_unreachable();         }     }     template<typename... U>     friend class shared_future; public:     using value_type = std::tuple<T...>;     using promise_type = promise<T...>;     [[gnu::always_inline]]     future(future&& x) noexcept : future_base(std::move(x), &_state), _state(std::move(x._state)) { }     future(const future&) = delete;     future& operator=(future&& x) noexcept {         this->~future();         new (this) future(std::move(x));         return *this;     }     void operator=(const future&) = delete;     [[gnu::always_inline]]     std::tuple<T...>&& get() {         if (!_state.available()) {             do_wait();         }         return get_available_state_ref().take();     }     [[gnu::always_inline]]      std::exception_ptr get_exception() {         return get_available_state_ref().get_exception();     }     typename future_state<T...>::get0_return_type get0() {         return future_state<T...>::get0(get());     }     void wait() noexcept {         if (!_state.available()) {             do_wait();         }     } private:     class thread_wake_task final : public continuation_base<T...> {         thread_context* _thread;         future* _waiting_for;     public:         thread_wake_task(thread_context* thread, future* waiting_for)                 : _thread(thread), _waiting_for(waiting_for) {         }         virtual void run_and_dispose() noexcept override {             _waiting_for->_state = std::move(this->_state);             thread_impl::switch_in(_thread);         }     };     void do_wait() noexcept {         if (__builtin_expect(!_promise, false)) {             _state.set_to_broken_promise();             return;         }         auto thread = thread_impl::get();         assert(thread);         thread_wake_task wake_task{thread, this};         detach_promise()->schedule(static_cast<continuation_base<T...>*>(&wake_task));         thread_impl::switch_out(thread);     } public:     [[gnu::always_inline]]     bool available() const noexcept {         return _state.available();     }     [[gnu::always_inline]]     bool failed() const noexcept {         return _state.failed();     }     template <typename Func, typename Result = futurize_t<std::result_of_t<Func(T&&...)>>>     GCC6_CONCEPT( requires ::seastar::CanApply<Func, T...> )     Result     then(Func&& func) noexcept {         return then_impl(std::move(func));     } private:     template <typename Func, typename Result = futurize_t<std::result_of_t<Func(T&&...)>>>     Result     then_impl(Func&& func) noexcept {         using futurator = futurize<std::result_of_t<Func(T&&...)>>;         if (available() && !need_preempt()) {             if (failed()) {                 return futurator::make_exception_future(static_cast<future_state_base&&>(get_available_state_ref()));             } else {                 return futurator::apply(std::forward<Func>(func), get_available_state_ref().take_value());             }         }         typename futurator::type fut(future_for_get_promise_marker{});         [&] () noexcept {             memory::disable_failure_guard dfg;             schedule([pr = fut.get_promise(), func = std::forward<Func>(func)] (future_state<T...>&& state) mutable {                 if (state.failed()) {                     pr.set_exception(static_cast<future_state_base&&>(std::move(state)));                 } else {                     futurator::apply(std::forward<Func>(func), std::move(state).get_value()).forward_to(std::move(pr));                 }             });         } ();         return fut;     } public:     template <typename Func, typename FuncResult = std::result_of_t<Func(future)>>     GCC6_CONCEPT( requires ::seastar::CanApply<Func, future> )     futurize_t<FuncResult>     then_wrapped(Func&& func) & noexcept {         return then_wrapped_maybe_erase<false, FuncResult>(std::forward<Func>(func));     }     template <typename Func, typename FuncResult = std::result_of_t<Func(future&&)>>     GCC6_CONCEPT( requires ::seastar::CanApply<Func, future&&> )     futurize_t<FuncResult>     then_wrapped(Func&& func) && noexcept {         return then_wrapped_maybe_erase<true, FuncResult>(std::forward<Func>(func));     } private:     template <bool AsSelf, typename FuncResult, typename Func>     futurize_t<FuncResult>     then_wrapped_maybe_erase(Func&& func) noexcept {         return then_wrapped_common<AsSelf, FuncResult>(std::forward<Func>(func));     }     template <bool AsSelf, typename FuncResult, typename Func>     futurize_t<FuncResult>     then_wrapped_common(Func&& func) noexcept {         using futurator = futurize<FuncResult>;         if (available() && !need_preempt()) {             if (AsSelf) {                 if (_promise) {                     detach_promise();                 }                 return futurator::apply(std::forward<Func>(func), std::move(*this));             } else {                 return futurator::apply(std::forward<Func>(func), future(get_available_state_ref()));             }         }         typename futurator::type fut(future_for_get_promise_marker{});         [&] () noexcept {             memory::disable_failure_guard dfg;             schedule([pr = fut.get_promise(), func = std::forward<Func>(func)] (future_state<T...>&& state) mutable {                 futurator::apply(std::forward<Func>(func), future(std::move(state))).forward_to(std::move(pr));             });         } ();         return fut;     }     void forward_to(internal::promise_base_with_type<T...>&& pr) noexcept {         if (_state.available()) {             pr.set_urgent_state(std::move(_state));         } else {             *detach_promise() = std::move(pr);         }     } public:     void forward_to(promise<T...>&& pr) noexcept {         if (_state.available()) {             pr.set_urgent_state(std::move(_state));         } else if (&pr._local_state != pr._state) {             *detach_promise() = std::move(pr);         }     }     template <typename Func>     GCC6_CONCEPT( requires ::seastar::CanApply<Func> )     future<T...> finally(Func&& func) noexcept {         return then_wrapped(finally_body<Func, is_future<std::result_of_t<Func()>>::value>(std::forward<Func>(func)));     }     template <typename Func, bool FuncReturnsFuture>     struct finally_body;     template <typename Func>     struct finally_body<Func, true> {         Func _func;         finally_body(Func&& func) : _func(std::forward<Func>(func))         { }         future<T...> operator()(future<T...>&& result) {             using futurator = futurize<std::result_of_t<Func()>>;             return futurator::apply(_func).then_wrapped([result = std::move(result)](auto f_res) mutable {                 if (!f_res.failed()) {                     return std::move(result);                 } else {                     try {                         f_res.get();                     } catch (...) {                         return result.rethrow_with_nested();                     }                     __builtin_unreachable();                 }             });         }     };     template <typename Func>     struct finally_body<Func, false> {         Func _func;         finally_body(Func&& func) : _func(std::forward<Func>(func))         { }         future<T...> operator()(future<T...>&& result) {             try {                 _func();                 return std::move(result);             } catch (...) {                 return result.rethrow_with_nested();             }         };     };     future<> or_terminate() noexcept {         return then_wrapped([] (auto&& f) {             try {                 f.get();             } catch (...) {                 engine_exit(std::current_exception());             }         });     }     future<> discard_result() noexcept {         return then([] (T&&...) {});     }     template <typename Func>     future<T...> handle_exception(Func&& func) noexcept {         using func_ret = std::result_of_t<Func(std::exception_ptr)>;         return then_wrapped([func = std::forward<Func>(func)]                              (auto&& fut) mutable -> future<T...> {             if (!fut.failed()) {                 return make_ready_future<T...>(fut.get());             } else {                 return futurize<func_ret>::apply(func, fut.get_exception());             }         });     }     template <typename Func>     future<T...> handle_exception_type(Func&& func) noexcept {         using trait = function_traits<Func>;         static_assert(trait::arity == 1, "func can take only one parameter");         using ex_type = typename trait::template arg<0>::type;         using func_ret = typename trait::return_type;         return then_wrapped([func = std::forward<Func>(func)]                              (auto&& fut) mutable -> future<T...> {             try {                 return make_ready_future<T...>(fut.get());             } catch(ex_type& ex) {                 return futurize<func_ret>::apply(func, ex);             }         });     }     void ignore_ready_future() noexcept {         _state.ignore();     } private:     void set_callback(continuation_base<T...>* callback) noexcept {         if (_state.available()) {             callback->set_state(get_available_state_ref());             ::seastar::schedule(callback);         } else {             assert(_promise);             detach_promise()->schedule(callback);         }     }     template <typename... U>     friend class future;     template <typename... U>     friend class promise;     template <typename... U>     friend class internal::promise_base_with_type;     template <typename... U, typename... A>     friend future<U...> make_ready_future(A&&... value);     template <typename... U>     friend future<U...> make_exception_future(std::exception_ptr&& ex) noexcept;     template <typename... U, typename Exception>     friend future<U...> make_exception_future(Exception&& ex) noexcept;     template <typename... U>     friend future<U...> internal::make_exception_future(future_state_base&& state) noexcept;     template <typename... U, typename V>     friend void internal::set_callback(future<U...>&, V*) noexcept; };
    template <typename... T, typename... A>  future<T...> make_ready_future(A&&... value) ;
 template <typename... T>  future<T...> make_exception_future(std::exception_ptr&& ex) noexcept ;
 template <typename... T>  future<T...> internal::make_exception_future(future_state_base&& state) noexcept ;
 template <typename... T> future<T...> internal::current_exception_as_future() noexcept ;
 void log_exception_trace() noexcept;
 template <typename... T, typename Exception>  future<T...> make_exception_future(Exception&& ex) noexcept ;
 template<typename T> template<typename Func, typename... FuncArgs> typename futurize<T>::type futurize<T>::apply(Func&& func, std::tuple<FuncArgs...>&& args) noexcept {     try {         return convert(::seastar::apply(std::forward<Func>(func), std::move(args)));     } catch (...) {         return internal::current_exception_as_future<T>();     } }
 template<typename T> template<typename Func, typename... FuncArgs> typename futurize<T>::type futurize<T>::apply(Func&& func, FuncArgs&&... args) noexcept {     try {         return convert(func(std::forward<FuncArgs>(args)...));     } catch (...) {         return internal::current_exception_as_future<T>();     } }
 template <typename Ret>   struct do_void_futurize_helper;
 template <> struct do_void_futurize_helper<void> {     template <typename Func, typename... FuncArgs>     static future<> apply(Func&& func, FuncArgs&&... args) noexcept {         try {             func(std::forward<FuncArgs>(args)...);             return make_ready_future<>();         } catch (...) {             return internal::current_exception_as_future<>();         }     }     template<typename Func, typename... FuncArgs>     static future<> apply_tuple(Func&& func, std::tuple<FuncArgs...>&& args) noexcept {         try {             ::seastar::apply(std::forward<Func>(func), std::move(args));             return make_ready_future<>();         } catch (...) {             return internal::current_exception_as_future<>();         }     } };
 template <> struct do_void_futurize_helper<future<>> {     template <typename Func, typename... FuncArgs>     static future<> apply(Func&& func, FuncArgs&&... args) noexcept {         try {             return func(std::forward<FuncArgs>(args)...);         } catch (...) {             return internal::current_exception_as_future<>();         }     }     template<typename Func, typename... FuncArgs>     static future<> apply_tuple(Func&& func, std::tuple<FuncArgs...>&& args) noexcept {         try {             return ::seastar::apply(std::forward<Func>(func), std::move(args));         } catch (...) {             return internal::current_exception_as_future<>();         }     } };
 template <typename Func, typename... FuncArgs> using void_futurize_helper = do_void_futurize_helper<std::result_of_t<Func(FuncArgs&&...)>>;
 template<typename Func, typename... FuncArgs> typename futurize<void>::type futurize<void>::apply(Func&& func, std::tuple<FuncArgs...>&& args) noexcept {     return void_futurize_helper<Func, FuncArgs...>::apply_tuple(std::forward<Func>(func), std::move(args)); }
 template<typename Func, typename... FuncArgs> typename futurize<void>::type futurize<void>::apply(Func&& func, FuncArgs&&... args) noexcept {     return void_futurize_helper<Func, FuncArgs...>::apply(std::forward<Func>(func), std::forward<FuncArgs>(args)...); }
 template<typename... Args> template<typename Func, typename... FuncArgs> typename futurize<future<Args...>>::type futurize<future<Args...>>::apply(Func&& func, std::tuple<FuncArgs...>&& args) noexcept {     try {         return ::seastar::apply(std::forward<Func>(func), std::move(args));     } catch (...) {         return internal::current_exception_as_future<Args...>();     } }
     template <typename T> inline future<T> futurize<T>::from_tuple(std::tuple<T>&& value) {     return make_ready_future<T>(std::move(value)); }
  inline future<> futurize<void>::from_tuple(std::tuple<>&& value) {     return make_ready_future<>(); }
 inline future<> futurize<void>::from_tuple(const std::tuple<>& value) {     return make_ready_future<>(); }
 template<typename Tag> class bool_class {     bool _value; public:     static const bool_class yes;     static const bool_class no;     constexpr bool_class()  ;     constexpr explicit bool_class(bool v) noexcept : _value(v) { }                                    };
 template<typename Tag> const bool_class<Tag> bool_class<Tag>::yes { true };
 template<typename Tag> const bool_class<Tag> bool_class<Tag>::no { false };
 }
  namespace seastar {
 namespace net { enum class ip_protocol_num : uint8_t {     icmp = 1, tcp = 6, udp = 17, unused = 255 }; enum class eth_protocol_num : uint16_t {     ipv4 = 0x0800, arp = 0x0806, ipv6 = 0x86dd }; const uint8_t eth_hdr_len = 14; const uint8_t tcp_hdr_len_min = 20; const uint8_t ipv4_hdr_len_min = 20; const uint8_t ipv6_hdr_len_min = 40; const uint16_t ip_packet_len_max = 65535; }
 namespace net { struct fragment {     char* base;     size_t size; }; struct offload_info {     ip_protocol_num protocol = ip_protocol_num::unused;     bool needs_csum = false;     uint8_t ip_hdr_len = 20;     uint8_t tcp_hdr_len = 20;     uint8_t udp_hdr_len = 8;     bool needs_ip_csum = false;     bool reassembled = false;     uint16_t tso_seg_size = 0;     compat::optional<uint16_t> vlan_tci; }; class packet final {     static constexpr size_t internal_data_size = 128 - 16;     static constexpr size_t default_nr_frags = 4;     struct pseudo_vector {         fragment* _start;         fragment* _finish;                                         };     struct impl {         deleter _deleter;         unsigned _len = 0;         uint16_t _nr_frags = 0;         uint16_t _allocated_frags;         offload_info _offload_info;         compat::optional<uint32_t> _rss_hash;         char _data[internal_data_size];          unsigned _headroom = internal_data_size;          fragment _frags[];                                                                                                            bool using_internal_data() const {             return _nr_frags                     && _frags[0].base >= _data                     && _frags[0].base < _data + internal_data_size;         }                  void copy_internal_fragment_to(impl* to) {             if (!using_internal_data()) {                 return;             }             to->_frags[0].base = to->_data + _headroom;             std::copy(_frags[0].base, _frags[0].base + _frags[0].size,                     to->_frags[0].base);         }     };     packet(std::unique_ptr<impl>&& impl) : _impl(std::move(impl)) {}     std::unique_ptr<impl> _impl; public:     static packet from_static_data(const char* data, size_t len) {         return {fragment{const_cast<char*>(data), len}, deleter()};     }     packet();     packet(size_t nr_frags);     packet(packet&& x) noexcept;     packet(const char* data, size_t len);     packet(fragment frag);     packet(fragment frag, deleter del);     packet(std::vector<fragment> frag, deleter del);     template <typename Iterator>     packet(Iterator begin, Iterator end, deleter del);     packet(packet&& x, fragment frag);     packet(fragment frag, packet&& x);     packet(fragment frag, deleter del, packet&& x);     packet(packet&& x, fragment frag, deleter d);     packet(packet&& x, temporary_buffer<char> buf);     packet(temporary_buffer<char> buf);     packet(packet&& x, deleter d);     packet& operator=(packet&& x) ;     unsigned len() const ;     unsigned memory() const ;     fragment frag(unsigned idx) const ;     fragment& frag(unsigned idx) ;     unsigned nr_frags() const ;     pseudo_vector fragments() const ;     fragment* fragment_array() const ;     packet share();     packet share(size_t offset, size_t len);     void append(packet&& p);     void trim_front(size_t how_much);     void trim_back(size_t how_much);     template <typename Header>     Header* get_header(size_t offset = 0);     char* get_header(size_t offset, size_t size);     template <typename Header>     Header* prepend_header(size_t extra_size = 0);     char* prepend_uninitialized_header(size_t size);     packet free_on_cpu(unsigned cpu, std::function<void()> cb = []{});     void linearize() ;     void reset() ;     void reserve(int n_frags) ;     compat::optional<uint32_t> rss_hash() ;     compat::optional<uint32_t> set_rss_hash(uint32_t hash) ;     template <typename Func>     void release_into(Func&& func) ;     std::vector<temporary_buffer<char>> release() ;     explicit operator bool() ;     static packet make_null_packet() ; private:     void linearize(size_t at_frag, size_t desired_size);     bool allocate_headroom(size_t size); public:     struct offload_info offload_info() const ;     struct offload_info& offload_info_ref() ;     void set_offload_info(struct offload_info oi) ; };                            }
 }
  namespace seastar {
 namespace internal { template <typename Future> struct continuation_base_from_future; template <typename... T> struct continuation_base_from_future<future<T...>> {     using type = continuation_base<T...>; }; template <typename HeldState, typename Future> class do_with_state final : public continuation_base_from_future<Future>::type {     HeldState _held;     typename Future::promise_type _pr; public:     explicit do_with_state(HeldState&& held) : _held(std::move(held)) {}     virtual void run_and_dispose() noexcept override {         _pr.set_urgent_state(std::move(this->_state));         delete this;     }     HeldState& data() {         return _held;     }     Future get_future() {         return _pr.get_future();     } }; }
 template<typename T, typename F> inline auto do_with(T&& rvalue, F&& f) {     auto task = std::make_unique<internal::do_with_state<T, std::result_of_t<F(T&)>>>(std::forward<T>(rvalue));     auto fut = f(task->data());     if (fut.available()) {         return fut;     }     auto ret = task->get_future();     internal::set_callback(fut, task.release());     return ret; }
 template <typename Tuple, size_t... Idx> inline auto cherry_pick_tuple(std::index_sequence<Idx...>, Tuple&& tuple) {     return std::make_tuple(std::get<Idx>(std::forward<Tuple>(tuple))...); }
 template<typename Lock, typename Func> inline auto with_lock(Lock& lock, Func&& func) {     return lock.lock().then([func = std::forward<Func>(func)] () mutable {         return func();     }).then_wrapped([&lock] (auto&& fut) {         lock.unlock();         return std::move(fut);     }); }
 template <typename T1, typename T2, typename T3_or_F, typename... More> inline auto do_with(T1&& rv1, T2&& rv2, T3_or_F&& rv3, More&&... more) {     auto all = std::forward_as_tuple(             std::forward<T1>(rv1),             std::forward<T2>(rv2),             std::forward<T3_or_F>(rv3),             std::forward<More>(more)...);     constexpr size_t nr = std::tuple_size<decltype(all)>::value - 1;     using idx = std::make_index_sequence<nr>;     auto&& just_values = cherry_pick_tuple(idx(), std::move(all));     auto&& just_func = std::move(std::get<nr>(std::move(all)));     using value_tuple = std::remove_reference_t<decltype(just_values)>;     using ret_type = decltype(apply(just_func, just_values));     auto task = std::make_unique<internal::do_with_state<value_tuple, ret_type>>(std::move(just_values));     auto fut = apply(just_func, task->data());     if (fut.available()) {         return fut;     }     auto ret = task->get_future();     internal::set_callback(fut, task.release());     return ret; }
 }
#include <boost/intrusive/list.hpp>
#include <bitset>
 namespace seastar {
 template<typename Timer, boost::intrusive::list_member_hook<> Timer::*link> class timer_set { public:     using time_point = typename Timer::time_point;     using timer_list_t = boost::intrusive::list<Timer, boost::intrusive::member_hook<Timer, boost::intrusive::list_member_hook<>, link>>; private:     using duration = typename Timer::duration;     using timestamp_t = typename Timer::duration::rep;     static constexpr timestamp_t max_timestamp = std::numeric_limits<timestamp_t>::max();     static constexpr int timestamp_bits = std::numeric_limits<timestamp_t>::digits;     static constexpr int n_buckets = timestamp_bits + 1;     std::array<timer_list_t, n_buckets> _buckets;     timestamp_t _last;     timestamp_t _next;     std::bitset<n_buckets> _non_empty_buckets; private:     static timestamp_t get_timestamp(time_point _time_point)     ;                     public:                                                   };
 };
  namespace seastar {
 using steady_clock_type = std::chrono::steady_clock;
 template <typename Clock = steady_clock_type> class timer { public:     typedef typename Clock::time_point time_point;     typedef typename Clock::duration duration;     typedef Clock clock; private:     using callback_t = noncopyable_function<void()>;     boost::intrusive::list_member_hook<> _link;     callback_t _callback;     time_point _expiry;     compat::optional<duration> _period;     bool _armed = false;     bool _queued = false;     bool _expired = false;           public:                                        void arm(duration delta) {         return arm(Clock::now() + delta);     }          bool armed() const ;     bool cancel();     time_point get_timeout() ;     friend class reactor;     friend class timer_set<timer, &timer::_link>; };
 extern template class timer<steady_clock_type>;
 template <typename Func, typename... Args>  auto with_scheduling_group(scheduling_group sg, Func func, Args&&... args) ;
 namespace internal { template <typename Iterator, typename IteratorCategory>  size_t iterator_range_estimate_vector_capacity(Iterator begin, Iterator end, IteratorCategory category) ; template <typename Iterator>  size_t iterator_range_estimate_vector_capacity(Iterator begin, Iterator end, std::forward_iterator_tag category) ; }
 class parallel_for_each_state final : private continuation_base<> {     std::vector<future<>> _incomplete;     promise<> _result;     std::exception_ptr _ex; private:     void wait_for_one() noexcept;     virtual void run_and_dispose() noexcept override; public:     parallel_for_each_state(size_t n);     void add_future(future<>&& f);     future<> get_future(); };
 template <typename Iterator, typename Func> GCC6_CONCEPT( requires requires (Func f, Iterator i) { { f(*i++) } -> future<>; }
 ) inline future<> parallel_for_each(Iterator begin, Iterator end, Func&& func) noexcept {     parallel_for_each_state* s = nullptr;     while (begin != end) {         auto f = futurize_apply(std::forward<Func>(func), *begin++);         if (!f.available() || f.failed()) {             if (!s) {                 using itraits = std::iterator_traits<Iterator>;                 auto n = (internal::iterator_range_estimate_vector_capacity(begin, end, typename itraits::iterator_category()) + 1);                 s = new parallel_for_each_state(n);             }             s->add_future(std::move(f));         }     }     if (s) {         return s->get_future();     }     return make_ready_future<>(); }
 template <typename Range, typename Func> GCC6_CONCEPT( requires requires (Func f, Range r) { { f(*r.begin()) } -> future<>; }
 ) inline future<> parallel_for_each(Range&& range, Func&& func) {     return parallel_for_each(std::begin(range), std::end(range),             std::forward<Func>(func)); }
 struct stop_iteration_tag { };
 using stop_iteration = bool_class<stop_iteration_tag>;
 namespace internal { template <typename AsyncAction> class repeater final : public continuation_base<stop_iteration> {     using futurator = futurize<std::result_of_t<AsyncAction()>>;     promise<> _promise;     AsyncAction _action; public:     explicit repeater(AsyncAction action) : _action(std::move(action)) {}     repeater(stop_iteration si, AsyncAction action) : repeater(std::move(action)) {         _state.set(std::make_tuple(si));     }           }; }
 template<typename AsyncAction> GCC6_CONCEPT( requires seastar::ApplyReturns<AsyncAction, stop_iteration> || seastar::ApplyReturns<AsyncAction, future<stop_iteration>> ) inline future<> repeat(AsyncAction action) noexcept {     using futurator = futurize<std::result_of_t<AsyncAction()>>;     static_assert(std::is_same<future<stop_iteration>, typename futurator::type>::value, "bad AsyncAction signature");     try {         do {             auto f = futurator::apply(action);             if (!f.available()) {               return [&] () noexcept {                 memory::disable_failure_guard dfg;                 auto repeater = new internal::repeater<AsyncAction>(std::move(action));                 auto ret = repeater->get_future();                 internal::set_callback(f, repeater);                 return ret;               }();             }             if (f.get0() == stop_iteration::yes) {                 return make_ready_future<>();             }         } while (!need_preempt());         auto repeater = new internal::repeater<AsyncAction>(stop_iteration::no, std::move(action));         auto ret = repeater->get_future();         schedule(repeater);         return ret;     } catch (...) {         return make_exception_future(std::current_exception());     } }
 template <typename T> struct repeat_until_value_type_helper;
 template <typename T> struct repeat_until_value_type_helper<future<compat::optional<T>>> {     using value_type = T;     using optional_type = compat::optional<T>;     using future_type = future<value_type>; };
 }
namespace seastar {
 namespace internal {  
}
  ;
  ;
#ifdef SEASTAR_USE_STD_OPTIONAL_VARIANT_STRINGVIEW
#endif
}
 namespace seastar {
 static constexpr size_t cache_line_size =     64;
 }
#include <boost/lockfree/spsc_queue.hpp>
#include <boost/program_options.hpp>
namespace seastar {
 namespace internal { namespace linux_abi { using aio_context_t = unsigned long; enum class iocb_cmd : uint16_t {     PREAD = 0,     PWRITE = 1,     FSYNC = 2,     FDSYNC = 3,     POLL = 5,     NOOP = 6,     PREADV = 7,     PWRITEV = 8, }; struct io_event {     uint64_t data;     uint64_t obj;     int64_t res;     int64_t res2; }; constexpr int IOCB_FLAG_RESFD = 1; struct iocb {         uint64_t   aio_data;  
#if __BYTE_ORDER == __LITTLE_ENDIAN
#endif
        iocb_cmd   aio_lio_opcode;         int16_t   aio_reqprio;         uint32_t   aio_fildes;         uint64_t   aio_buf;         uint64_t   aio_nbytes;         int64_t   aio_offset;         uint64_t   aio_reserved2;         uint32_t   aio_flags;         uint32_t   aio_resfd; }; struct aio_sigset {     const sigset_t *sigmask;     size_t sigsetsize; }; }                  }
 namespace internal {                       }
 }
#include <sys/un.h>
  namespace seastar {
 struct ipv6_addr;
 class socket_address { public:     socklen_t addr_length;      union {         ::sockaddr_storage sas;         ::sockaddr sa;         ::sockaddr_in in;         ::sockaddr_in6 in6;         ::sockaddr_un un;     } u;                                             /** creates an uninitialized socket_address. this can be written into, or used as      *  "unspecified" for such addresses as bind(addr) or local address in socket::connect      *  (i.e. system picks)      */    socket_address();                                        ;                                         };
 class lowres_clock;
 class lowres_system_clock;
 class lowres_clock_impl final { public:     using base_steady_clock = std::chrono::steady_clock;     using base_system_clock = std::chrono::system_clock;     using period = std::ratio<1, 1000>;     using steady_rep = base_steady_clock::rep;     using steady_duration = std::chrono::duration<steady_rep, period>;     using steady_time_point = std::chrono::time_point<lowres_clock, steady_duration>;     using system_rep = base_system_clock::rep;     using system_duration = std::chrono::duration<system_rep, period>;     using system_time_point = std::chrono::time_point<lowres_system_clock, system_duration>;               friend class smp; private:     struct alignas(seastar::cache_line_size) counters final {         static std::atomic<steady_rep> _steady_now;         static std::atomic<system_rep> _system_now;     };     static constexpr std::chrono::milliseconds _granularity{10};     timer<> _timer{};           };
 class lowres_clock final { public:     using rep = lowres_clock_impl::steady_rep;     using period = lowres_clock_impl::period;     using duration = lowres_clock_impl::steady_duration;     using time_point = lowres_clock_impl::steady_time_point;     static constexpr bool is_steady = true;      };
 class lowres_system_clock final { public:     using rep = lowres_clock_impl::system_rep;     using period = lowres_clock_impl::period;     using duration = lowres_clock_impl::system_duration;     using time_point = lowres_clock_impl::system_time_point;     static constexpr bool is_steady = lowres_clock_impl::base_system_clock::is_steady;                };
 }
 namespace seastar {
 enum class log_level {     error,     warn,     info,     debug,     trace, };
 class logger {     sstring _name;     std::atomic<log_level> _level = { log_level::info };     static std::ostream* _out;     static std::atomic<bool> _ostream;     static std::atomic<bool> _syslog; private:     struct stringer {         void (*append)(std::ostream& os, const void* object);         const void* object;     };      ;;     ;           public:                               ;      ;      ;      ;      ;      ;      ;                              [[deprecated("Use set_ostream_enabled instead")]]     static void set_stdout_enabled(bool enabled);      };
 class logger_registry {     mutable std::mutex _mutex;     std::unordered_map<sstring, logger*> _loggers; public:                                    };
   template <typename T> class logger_for : public logger { public:      };
  }
  namespace seastar {
 class manual_clock { public:     using rep = int64_t;     using period = std::chrono::nanoseconds::period;     using duration = std::chrono::duration<rep, period>;     using time_point = std::chrono::time_point<manual_clock, duration>; private:     static std::atomic<rep> _now;      public:                };
 extern template class timer<manual_clock>;
 }
  /*!  * \file metrics_registration.hh  * \brief holds the metric_groups definition needed by class that reports metrics  *  * If class A needs to report metrics,  * typically you include metrics_registration.hh, in A header file and add to A:  * * metric_groups _metrics as a member  * * set_metrics() method that would be called in the constructor.  * \code  * class A {
  *   metric_groups _metrics  *  *   void setup_metrics();
  *  * };
   * \endcode  * To define the metrics, include in your source file metircs.hh  * @see metrics.hh for the definition for adding a metric.  */
namespace seastar {
 namespace metrics { namespace impl { class metric_groups_def; struct metric_definition_impl; class metric_groups_impl; } using group_name_type = sstring; /*!< A group of logically related metrics */class metric_groups; class metric_definition {     std::unique_ptr<impl::metric_definition_impl> _impl; public:                    friend metric_groups;     friend impl::metric_groups_impl; }; class metric_group_definition { public:     group_name_type name;     std::initializer_list<metric_definition> metrics;                }; /*!  * metric_groups  * \brief holds the metric definition.  *  * Add multiple metric groups definitions.  * Initialization can be done in the constructor or with a call to add_group  * @see metrics.hh for example and supported metrics  */class metric_groups {     std::unique_ptr<impl::metric_groups_def> _impl; public:                         /*!      * \brief add metrics belong to the same group in the constructor.      *      * combine the constructor with the add_group functionality.      */         /*!      * \brief Add metrics belonging to the same group.      *      * Use the metrics creation functions to add metrics.      *      * For example:      *  _metrics.add_group("my_group", {      *      make_counter("my_counter_name1", counter, description("my counter description")),      *      make_counter("my_counter_name2", counter, description("my second counter description")),      *      make_gauge("my_gauge_name1", gauge, description("my gauge description")),      *  });      *      * Metric name should be unique inside the group.      * You can chain add_group calls like:      * _metrics.add_group("my group1", {...}).add_group("my group2", {...});      *      * This overload (with initializer_list) is needed because metric_definition      * has no copy constructor, so the other overload (with vector) cannot be      * invoked on a braced-init-list.      */         /*!      * \brief Add metrics belonging to the same group.      *      * Use the metrics creation functions to add metrics.      *      * For example:      *  vector<metric_definition> v;      *  v.push_back(make_counter("my_counter_name1", counter, description("my counter description")));      *  v.push_back(make_counter("my_counter_name2", counter, description("my second counter description")));      *  v.push_back(make_gauge("my_gauge_name1", gauge, description("my gauge description")));      *  _metrics.add_group("my_group", v);      *      * Metric name should be unique inside the group.      * You can chain add_group calls like:      * _metrics.add_group("my group1", vec1).add_group("my group2", vec2);      */         /*!      * \brief clear all metrics groups registrations.      */     }; /*!  * \brief hold a single metric group  * Initialization is done in the constructor or  * with a call to add_group  */class metric_group : public metric_groups { public:                              /*!      * \brief add metrics belong to the same group in the constructor.      *      *      */     }; }
 /*!  * \namespace seastar::metrics  * \brief metrics creation and registration  *  * the metrics namespace holds the relevant method and classes to generate metrics.  *  * The metrics layer support registering metrics, that later will be  * exported via different API protocols.  *  * To be able to support multiple protocols the following simplifications where made:  * 1. The id of the metrics is based on the collectd id  * 2. A metric could be a single value either a reference or a function  *  * To add metrics definition to class A do the following:  * * Add a metrics_group memeber to A  * * Add a a set_metrics() method that would be called in the constructor.  *  *  * In A header file  * \code  *   * class A {  *   metric_groups _metrics  *  *   void setup_metrics();  *  * };
  * \endcode  *  * In A source file:  *  * \code  * include "core/metrics.hh"  *  * void A::setup_metrics() {  *   namespace sm = seastar::metrics;  *   _metrics = sm::create_metric_group();  *   _metrics->add_group("cache", {sm::make_gauge("bytes", "used", [this] { return _region.occupancy().used_space(); })});  * }
  * \endcode  */namespace metrics { class double_registration : public std::runtime_error { public:      }; /*!  * \defgroup metrics_types metrics type definitions  * The following are for the metric layer use, do not use them directly  * Instead use the make_counter, make_gauge, make_absolute and make_derived  *  */using metric_type_def = sstring; /*!< Used to hold an inherit type (like bytes)*/using metric_name_type = sstring; /*!<  The metric name'*/
class description {
enum class data_type : uint8_t {
};
struct metric_value {
};
using metric_function = std::function<metric_value()>;
struct metric_type {
};
template<typename T, typename En = std::true_type>
metric_function make_function(T& val, data_type dt) {
    return [dt, &val] {
    };
}
}
 ;
}
}
namespace seastar {
namespace internal {
};
}
namespace seastar {
namespace internal {
class io_request {
    union {
    } _size;
};
}
}
#include <boost/intrusive_ptr.hpp>
namespace seastar {
class pollable_fd;
class pollable_fd_state;
using pollable_fd_state_ptr = boost::intrusive_ptr<pollable_fd_state>;
class pollable_fd_state {
public:
    struct speculation {
    };
    future<std::tuple<pollable_fd, socket_address>> accept();
};
}
namespace seastar {
struct pollfn {
};
}
extern "C" int _Unwind_RaiseException(struct _Unwind_Exception *h);
namespace seastar {
namespace alien {
class message_queue;
}
size_t iovec_len(const std::vector<iovec>& iov)
{
    size_t ret = 0;
    return ret;
}
}
namespace std {
template <>
struct hash<::sockaddr_in> {
};
}
namespace seastar {
namespace internal {
}
class reactor {
    struct io_stats {
        /**
         */
    };
    class signals {
        struct signal_handler {
        };
    };
    /**
     * If it returns FALSE then reactor's main loop is forbidden to block in the      * current iteration.      *      * @param fn a new "poller" function to register      */                                                                                         friend class alien::message_queue;     friend class pollable_fd;     friend class pollable_fd_state;     friend struct pollable_fd_state_deleter;     friend class posix_file_impl;     friend class blockdev_file_impl;     friend class readable_eventfd;     friend class timer<>;     friend class timer<lowres_clock>;     friend class timer<manual_clock>;     friend class smp;     friend class smp_message_queue;     friend class poller;     friend class scheduling_group;          friend int ::_Unwind_RaiseException(struct _Unwind_Exception *h);          metrics::metric_groups _metric_groups;                         ;     ;     template<typename SpecificValType, typename Mapper, typename Reducer, typename Initial>         GCC6_CONCEPT( requires requires(SpecificValType specific_val, Mapper mapper, Reducer reducer, Initial initial) {             {reducer(initial, mapper(specific_val))} -> Initial;         })     friend future<typename function_traits<Reducer>::return_type>     map_reduce_scheduling_group_specific(Mapper mapper, Reducer reducer, Initial initial_val, scheduling_group_key key);     template<typename SpecificValType, typename Reducer, typename Initial>     GCC6_CONCEPT( requires requires(SpecificValType specific_val, Reducer reducer, Initial initial) {         {reducer(initial, specific_val)} -> Initial;     })     friend future<typename function_traits<Reducer>::return_type>         reduce_scheduling_group_specific(Reducer reducer, Initial initial_val, scheduling_group_key key); public:                                                             };
 extern logger seastar_logger;
 }
  using data_type = shared_ptr<const abstract_type>;
  class column_set {
};
  class schema final : public enable_lw_shared_from_this<schema> {
   struct column {     bytes name;     data_type type;   };
 public:   schema(std::optional<utils::UUID> id, std::string_view ks_name,          std::string_view cf_name, std::vector<column> partition_key,          std::vector<column> clustering_key,          std::vector<column> regular_columns,          std::vector<column> static_columns, data_type regular_column_name_type,          std::string_view comment = {}
);
   ~schema();
 public: };
  struct blob_storage {
   struct [[gnu::packed]] ref_type {     blob_storage *ptr;     ref_type() {}     ref_type(blob_storage * ptr) : ptr(ptr) {}     operator blob_storage *() const { return ptr; }     blob_storage *operator->() const { return ptr; }     blob_storage &operator*() const { return *ptr; }   };
 }
  __attribute__((packed));
  class table;
  using column_family = table;
  class clustering_key_prefix;
  template <typename T> class nonwrapping_range {
};
  GCC6_CONCEPT(template <template <typename> typename T, typename U>              concept bool Range =                  std::is_same<T<U>, wrapping_range<U>>::value ||                  std::is_same<T<U>, nonwrapping_range<U>>::value;
 ) namespace std {
}
  namespace dht {
 class decorated_key;
 }
  template <typename EnumType, EnumType... Items> struct super_enum {
};
  template <typename Enum> class enum_set {
};
  namespace tracing {
 class trace_state_ptr;
 }
  namespace query {
 using column_id_vector = utils::small_vector<column_id, 8>;
 using clustering_range = nonwrapping_range<clustering_key_prefix>;
 typedef std::vector<clustering_range> clustering_row_ranges;
 class specific_ranges {};
 constexpr auto max_rows = std::numeric_limits<uint32_t>::max();
 class partition_slice { public:   enum class option {     send_clustering_key,     send_partition_key,     send_timestamp,     send_expiry,     reversed,     distinct,     collections_as_maps,     send_ttl,     allow_short_read,     with_digest,     bypass_cache,     always_return_static_content,   };   using option_set = enum_set<super_enum<       option, option::send_clustering_key, option::send_partition_key,       option::send_timestamp, option::send_expiry, option::reversed,       option::distinct, option::collections_as_maps, option::send_ttl,       option::allow_short_read, option::with_digest, option::bypass_cache,       option::always_return_static_content>>; public:   partition_slice(       clustering_row_ranges row_ranges, column_id_vector static_columns,       column_id_vector regular_columns, option_set options,       std::unique_ptr<specific_ranges> specific_ranges = nullptr,       cql_serialization_format = cql_serialization_format::internal(),       uint32_t partition_row_limit = max_rows);   partition_slice(clustering_row_ranges ranges, const schema &schema,                   const column_set &mask, option_set options);   partition_slice(const partition_slice &); };
 }
  namespace db {
 using timeout_clock = seastar::lowres_clock;
 }
  GCC6_CONCEPT(template <typename T, typename ReturnType>              concept bool MutationFragmentConsumer() {
   return requires(F f, mutation_fragment mf, schema_ptr s) {     { f(std::move(mf)) }     ->mutation_fragment;     { f(s) }     ->schema_ptr;   };
 }
 ) class mutation final {
   mutation() = default;
 public:   const dht::decorated_key &decorated_key() const;
 };
  using mutation_opt = optimized_optional<mutation>;
  class flat_mutation_reader;
  future<mutation_opt> read_mutation_from_flat_mutation_reader(flat_mutation_reader &reader,                                         db::timeout_clock::time_point timeout);
  class locked_cell;
  class frozen_mutation;
  class table {
 public:   future<std::vector<locked_cell>>   lock_counter_cells(const mutation &m, db::timeout_clock::time_point timeout);
 };
  class database {
 private:   future<mutation>   do_apply_counter_update(column_family &cf, const frozen_mutation &fm,                           schema_ptr m_schema,                           db::timeout_clock::time_point timeout,                           tracing::trace_state_ptr trace_state);
 public: };
  namespace tracing {
 class trace_state_ptr final { public:   trace_state_ptr();   trace_state_ptr(nullptr_t); };
 }
   template <typename Consumer> inline future<> consume_partitions(flat_mutation_reader &reader,                                    Consumer consumer,                                    db::timeout_clock::time_point timeout) {
   using futurator = futurize<std::result_of_t<Consumer(mutation &&)>>;
   return do_with(       std::move(consumer), [&reader, timeout](Consumer &c) -> future<> {         return repeat([&reader, &c, timeout]() {           return read_mutation_from_flat_mutation_reader(reader, timeout)               .then([&c](mutation_opt &&mo) -> future<stop_iteration> {                 if (!mo) {                   return make_ready_future<stop_iteration>(stop_iteration::yes);                 }                 return futurator::apply(c, std::move(*mo));               });         });       }
);
 }
  class frozen_mutation final {
 public:   frozen_mutation(const mutation &m);
   mutation unfreeze(schema_ptr s) const;
 };
  class mutation_source {
};
  future<mutation_opt> counter_write_query(schema_ptr, const mutation_source &,                                          const dht::decorated_key &dk,                                          const query::partition_slice &slice,                                          tracing::trace_state_ptr trace_ptr);
  class locked_cell {
};
  future<mutation> database::do_apply_counter_update(column_family &cf, const frozen_mutation &fm,                                   schema_ptr m_schema,                                   db::timeout_clock::time_point timeout,                                   tracing::trace_state_ptr trace_state) {
   auto m = fm.unfreeze(m_schema);
   query::column_id_vector static_columns;
   query::clustering_row_ranges cr_ranges;
   query::column_id_vector regular_columns;
   auto slice = query::partition_slice(       std::move(cr_ranges), std::move(static_columns),       std::move(regular_columns), {}
, {}
, cql_serialization_format::internal(),       query::max_rows);
   return do_with(       std::move(slice), std::move(m), std::vector<locked_cell>(),       [this, &cf, timeout](const query::partition_slice &slice, mutation &m,                            std::vector<locked_cell> &locks) mutable {         return cf.lock_counter_cells(m, timeout)             .then([&, timeout, this](std::vector<locked_cell> lcs) mutable {               locks = std::move(lcs);               return counter_write_query(schema_ptr(), mutation_source(),                                          m.decorated_key(), slice, nullptr)                   .then([this, &cf, &m, timeout](auto mopt) {                     return std::move(m);                   });             });       }
);
 }
